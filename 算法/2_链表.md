# é“¾è¡¨:chains:

### 1. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨:avocado:

:point_right:[**LeetCode21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨**](https://leetcode.cn/problems/merge-two-sorted-lists/description/) 

:alien:**æ€è·¯è§£æï¼š** 

- åŒæŒ‡é’ˆ `p1` `p2` åˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªé“¾è¡¨å¤´ç»“ç‚¹
- åˆ›å»ºæ–°é“¾è¡¨æŒ‡é’ˆ `p` ç»´æŠ¤ï¼ˆæŠ€å·§ï¼šè™šæ‹Ÿå¤´ç»“ç‚¹ `dummy`ï¼‰
- éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œè¾ƒå°çš„ç»“ç‚¹ä¼˜å…ˆç»™ `p` æŒ‡é’ˆï¼Œç»ˆæ­¢æ¡ä»¶å­˜åœ¨é“¾è¡¨ï¼ˆä»»æ„ä¸€ä¸ªæˆ–ä¸¤ä¸ªéƒ½ï¼‰éå†å®Œæˆ
- åˆ¤æ–­ `p1` `p2` æ˜¯å¦éç©ºï¼Œéç©ºåˆ™è¿½åŠ ç»™ `p` æŒ‡é’ˆ

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        ListNode* p1 = list1; 
        ListNode* p2 = list2;
        
        while(p1!=nullptr && p2!=nullptr){
            // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ
        	// å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ
            if (p1->val <= p2->val){
                p->next = p1;
                p1 = p1->next;
            }
            else{
                p->next = p2;
                p2 = p2->next;
            }
            p = p->next;
        }
        if (p1ï¼=nullptr){
            p->next = p1;
        }
        if (p2ï¼=nullptr){
            p->next = p2;
        }
        return dummy->next;
    }
};
```

- [x] **ã€Œè™šæ‹Ÿå¤´ç»“ç‚¹ã€æŠ€å·§ï¼Œä¹Ÿå°±æ˜¯ `dummy` èŠ‚ç‚¹** :  
  å¦‚æœä¸ä½¿ç”¨ `dummy` è™šæ‹ŸèŠ‚ç‚¹ï¼Œä»£ç ä¼šå¤æ‚å¾ˆå¤šï¼Œè€Œæœ‰äº† `dummy` èŠ‚ç‚¹è¿™ä¸ªå ä½ç¬¦ï¼Œå¯ä»¥é¿å…å¤„ç†ç©ºæŒ‡é’ˆçš„æƒ…å†µï¼Œé™ä½ä»£ç çš„å¤æ‚æ€§ã€‚  
  **å½“ä½ éœ€è¦åˆ›é€ ä¸€æ¡æ–°é“¾è¡¨çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨è™šæ‹Ÿå¤´ç»“ç‚¹ç®€åŒ–è¾¹ç•Œæƒ…å†µçš„å¤„ç†**ã€‚

### 2. é“¾è¡¨çš„åˆ†è§£:bacon:

:point_right:[**Leetcode86. åˆ†éš”é“¾è¡¨**](https://leetcode.cn/problems/partition-list/) 

:alien:**æ€è·¯è§£æï¼š** 

- `p` æŒ‡é’ˆéå†åŸé“¾è¡¨ï¼Œæ¯”è¾ƒåˆ†åŒºï¼Œç»ˆæ­¢æ¡ä»¶åŸé“¾è¡¨éå†å®Œæˆ
- åŒæŒ‡é’ˆ `p1` `p2` åˆ†åˆ«ç»´æŠ¤ä¸¤ä¸ªåˆ†åŒºæ–°é“¾è¡¨ï¼ˆæŠ€å·§ï¼šè™šæ‹Ÿå¤´ç»“ç‚¹ `dummy1` `dummy2`ï¼‰
- æ–­å¼€åŸé“¾è¡¨ä¸­æ¯ä¸ªèŠ‚ç‚¹

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        // å­˜æ”¾å°äº x çš„é“¾è¡¨çš„è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy1 = new ListNode(-1);
        // å­˜æ”¾å¤§äºç­‰äº x çš„é“¾è¡¨çš„è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy2 = new ListNode(-1);
        // p1, p2 æŒ‡é’ˆè´Ÿè´£ç”Ÿæˆç»“æœé“¾è¡¨
        ListNode* p1 = dummy1;
        ListNode* p2 = dummy2;
        // p è´Ÿè´£éå†åŸé“¾è¡¨ï¼Œç±»ä¼¼åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘
    	// è¿™é‡Œæ˜¯å°†ä¸€ä¸ªé“¾è¡¨åˆ†è§£æˆä¸¤ä¸ªé“¾è¡¨
        ListNode* p = head;
        while (p!=nullptr){
            if (p->val < x){
                p1->next = p;
                p1 = p1->next;
            }
            else{
                p2->next = p;
                p2 = p2->next;
            }
            // æ–­å¼€åŸé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆ
            ListNode* tmp = p->next;
            p->next = nullptr;
            p = tmp;
        }
        // è¿æ¥ä¸¤ä¸ªé“¾è¡¨
        p1->next = dummy2->next;
        return dummy1->next;
    }
};
```

### 3. åˆå¹¶ k ä¸ªæœ‰åºé“¾è¡¨:cherries:

:point_right:[**Leetcode23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨**](https://leetcode.cn/problems/partition-list/) 

:alien:**æ€è·¯è§£æï¼š** 

- åˆ›å»ºæ–°é“¾è¡¨æŒ‡é’ˆ `p` ç»´æŠ¤ï¼ˆæŠ€å·§ï¼šè™šæ‹Ÿå¤´ç»“ç‚¹ `dummy`ï¼‰
- ä¼˜å…ˆçº§é˜Ÿåˆ— [**priority_queue** ](https://zh.cppreference.com/w/cpp/container/priority_queue) ï¼ˆæœ€å°å †ï¼‰å®ç°è¾ƒå°èŠ‚ç‚¹ä¼˜å…ˆç»™ `p` æŒ‡é’ˆ

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() == 0) return nullptr;
		// è™šæ‹Ÿå¤´ç»“ç‚¹
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
		// ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å †
        auto cmp = [](ListNode* a, ListNode* b) { return (a->val) > (b->val); };
        priority_queue < ListNode*, vector<ListNode*>,decltype(cmp)>  pq(cmp);
        // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å †
        for (ListNode* head : lists) {
            if (head != nullptr)
                pq.push(head);
        }

        while (!pq.empty()) {
            // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­
            ListNode* node = pq.top();
            pq.pop();
            p->next = node;
            if (node->next != nullptr) {
                pq.push(node->next);
            }
            // p æŒ‡é’ˆä¸æ–­å‰è¿›
            p = p->next;
        }
        return dummy->next;
    }
};
```

- [x] ä¼˜å…ˆé˜Ÿåˆ— `pq` ä¸­çš„å…ƒç´ ä¸ªæ•°æœ€å¤šæ˜¯ `k`ï¼Œæ‰€ä»¥ä¸€æ¬¡ `pop` æˆ–è€… `push` æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(logk)`ï¼›  
  æ‰€æœ‰çš„é“¾è¡¨èŠ‚ç‚¹éƒ½ä¼šè¢«åŠ å…¥å’Œå¼¹å‡º `pq`ï¼Œ**æ‰€ä»¥ç®—æ³•æ•´ä½“çš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(Nlogk)`ï¼Œå…¶ä¸­ `k` æ˜¯é“¾è¡¨çš„æ¡æ•°ï¼Œ`N` æ˜¯è¿™äº›é“¾è¡¨çš„èŠ‚ç‚¹æ€»æ•°**ã€‚

### 4. é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹:doughnut: 

å…ˆè®©ä¸€ä¸ªæŒ‡é’ˆ `p1` æŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`ï¼Œç„¶åèµ° `k` æ­¥

å†ç”¨ä¸€ä¸ªæŒ‡é’ˆ `p2` æŒ‡å‘é“¾è¡¨å¤´èŠ‚ç‚¹ `head` 

è®© `p1` å’Œ `p2` åŒæ—¶å‘å‰èµ°ï¼Œ`p1` èµ°åˆ°é“¾è¡¨æœ«å°¾çš„ç©ºæŒ‡é’ˆæ—¶å‰è¿›äº† `n - k` æ­¥ï¼Œ`p2` ä¹Ÿä» `head` å¼€å§‹å‰è¿›äº† `n - k` æ­¥ï¼Œåœç•™åœ¨ç¬¬ `n - k + 1` ä¸ªèŠ‚ç‚¹ä¸Šï¼Œå³æ°å¥½åœé“¾è¡¨çš„å€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹ä¸Š

:point_right:[**Leetcode19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹**](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) 

:alien:**æ€è·¯è§£æï¼š** 

- å°è£…>>>é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹æ–¹æ³•
- å»ºç«‹è™šæ‹Ÿå¤´ç»“ç‚¹
- æ‰¾åˆ°å€’æ•°ç¬¬ `n+1` ä¸ªèŠ‚ç‚¹ï¼Œåˆ é™¤ç¬¬ `n` ä¸ªèŠ‚ç‚¹ 

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* FindNthFromEnd(ListNode* head, int n) {
                ListNode* p1 = head;
        		// p1 å…ˆèµ° k æ­¥
                for(int i=0;i<n;i++){
                    p1 = p1->next;
                }
                ListNode* p2 = head;
        		// p1 å’Œ p2 åŒæ—¶èµ° n - k æ­¥
                while(p1!=nullptr){
                    p1 = p1->next;
                    p2 = p2->next;
                }
        		// p2 ç°åœ¨æŒ‡å‘ç¬¬ n - k + 1 ä¸ªèŠ‚ç‚¹ï¼Œå³å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹
                return p2;
            }
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        	// è™šæ‹Ÿå¤´ç»“ç‚¹
            ListNode* dummy = new ListNode(-1);
            dummy->next = head;
        	// åˆ é™¤å€’æ•°ç¬¬ n ä¸ªï¼Œè¦å…ˆæ‰¾å€’æ•°ç¬¬ n + 1 ä¸ªèŠ‚ç‚¹
            ListNode* x = FindNthFromEnd(dummy, n+1);
        	// åˆ æ‰å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹
            x->next = x->next->next;
            return dummy->next;
    }
};
```

- [x] è™šæ‹Ÿå¤´ç»“ç‚¹æŠ€å·§ï¼Œé˜²æ­¢åˆ é™¤å¤´ç»“ç‚¹æ—¶å‡ºé”™ï¼Œå› ä¸ºéœ€è¦æ‰¾åˆ°å€’æ•°ç¬¬ `n+1` ä¸ªèŠ‚ç‚¹

### 5. é“¾è¡¨çš„ä¸­ç‚¹:egg:

:point_right:[**Leetcode876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹**](https://leetcode.cn/problems/middle-of-the-linked-list/) 

:alien:**æ€è·¯è§£æï¼š** 

ã€:ticket:ã€‘ **å¿«æ…¢æŒ‡é’ˆ**   
              æ¯å½“æ…¢æŒ‡é’ˆ `slow` å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ `fast` å°±å‰è¿›ä¸¤æ­¥ï¼Œè¿™æ ·ï¼Œå½“ `fast` èµ°åˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œ`slow` å°±æŒ‡å‘äº†é“¾è¡¨ä¸­ç‚¹

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=nullptr && fast->next!=nullptr){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

- [x] å½“é“¾è¡¨é•¿åº¦ä¸ºå¶æ•°æ—¶ï¼Œè¿”å›ä¸­ç‚¹ä¸¤ä¸ªèŠ‚ç‚¹é åçš„èŠ‚ç‚¹

### 6. é“¾è¡¨æ˜¯å¦åŒ…å«ç¯:fries:

:point_right:[**Leetcode141. ç¯å½¢é“¾è¡¨**](https://leetcode.cn/problems/linked-list-cycle/) 

:alien:**æ€è·¯è§£æï¼š** 

ã€:ticket:ã€‘ **å¿«æ…¢æŒ‡é’ˆ**   
              æ¯å½“æ…¢æŒ‡é’ˆ `slow` å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ `fast` å°±å‰è¿›ä¸¤æ­¥  
              å¦‚æœ `fast` æœ€ç»ˆé‡åˆ°ç©ºæŒ‡é’ˆï¼Œè¯´æ˜é“¾è¡¨ä¸­æ²¡æœ‰ç¯  
              å¦‚æœ `fast` æœ€ç»ˆå’Œ `slow` ç›¸é‡ï¼Œé‚£è‚¯å®šæ˜¯ `fast` è¶…è¿‡äº† `slow` ä¸€åœˆï¼Œè¯´æ˜é“¾è¡¨ä¸­å«æœ‰ç¯

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=nullptr && fast->next!=nullptr){
            fast = fast->next->next;
            slow = slow->next;
            // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
            if (fast==slow)
                return true;
        }
        return false;
    }
};
```

:point_right:[**Leetcode142. ç¯å½¢é“¾è¡¨ II**](https://leetcode.cn/problems/linked-list-cycle-ii/) 

:alien:**æ€è·¯è§£æï¼š** 

ã€:ticket:ã€‘ **å¿«æ…¢æŒ‡é’ˆ**   
              å½“å¿«æ…¢æŒ‡é’ˆç›¸é‡æ—¶ï¼Œè®©å…¶ä¸­ä»»ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œç„¶åè®©å®ƒä¿©ä»¥ç›¸åŒé€Ÿåº¦å‰è¿›ï¼Œå†æ¬¡ç›¸é‡æ—¶æ‰€åœ¨çš„èŠ‚ç‚¹ä½ç½®å°±æ˜¯ç¯å¼€å§‹çš„ä½ç½®

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=nullptr && fast->next!=nullptr){
            fast = fast->next->next;
            slow = slow->next;
            // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜å«æœ‰ç¯
            if (fast==slow)
                break;
        }
        if (fast==nullptr || fast->next==nullptr){
            return nullptr;
        }
        // é‡æ–°æŒ‡å‘å¤´ç»“ç‚¹
        slow = head;
        // å¿«æ…¢æŒ‡é’ˆåŒæ­¥å‰è¿›ï¼Œç›¸äº¤ç‚¹å°±æ˜¯ç¯èµ·ç‚¹
        while(fast!=slow){
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }
};
```

### 7. é“¾è¡¨æ˜¯å¦ç›¸äº¤:green_apple:

:point_right:[**Leetcode160. ç›¸äº¤é“¾è¡¨**](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 

:alien:**æ€è·¯è§£æï¼š** 

ã€:pushpin:ã€‘**åŒæŒ‡é’ˆ**  
			 è®© `p1` éå†å®Œé“¾è¡¨ `A` ä¹‹åå¼€å§‹éå†é“¾è¡¨ `B`ï¼Œè®© `p2` éå†å®Œé“¾è¡¨ `B` ä¹‹åå¼€å§‹éå†é“¾è¡¨ `A`   
			 æœ€åè®© `p1` å’Œ `p2` èƒ½å¤ŸåŒæ—¶åˆ°è¾¾ç›¸äº¤èŠ‚ç‚¹ `c1` 

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* p1 = headA;
        ListNode* p2 = headB;
        while(p1!=p2){
            if (p1==nullptr)
                p1 = headB;
            else
                p1 = p1->next;
            if (p2==nullptr)
                p2 = headA;
            else
                p2 = p2->next;
        }
        return p1;
    }
};
```

- [x] é“¾è¡¨ä¸ç›¸äº¤æœ€åä¼šåœæ­¢åœ¨"æ‹¼æ¥"é“¾è¡¨å°¾éƒ¨ `nullptr` ï¼ŒåŒ…å«è¿”å› `null` çš„æƒ…å†µ

---
> âœï¸ [é‚¢ç¦å‡¯ (xfkcode@github)](https://github.com/xfkcode)  
> ğŸ“… **å†™äº2023å¹´1æœˆ** 
