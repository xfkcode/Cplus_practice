# äºŒå‰æ ‘(æ€è·¯):cactus: 

äºŒå‰æ ‘è§£é¢˜çš„æ€ç»´æ¨¡å¼åˆ†ä¸¤ç±»ï¼š

**1. æ˜¯å¦å¯ä»¥é€šè¿‡éå†ä¸€éäºŒå‰æ ‘å¾—åˆ°ç­”æ¡ˆ**ï¼Ÿ  
	å¦‚æœå¯ä»¥ï¼Œç”¨ä¸€ä¸ª `traverse` å‡½æ•°é…åˆå¤–éƒ¨å˜é‡æ¥å®ç°ï¼Œè¿™å«ã€Œéå†ã€çš„æ€ç»´æ¨¡å¼ã€‚

**2. æ˜¯å¦å¯ä»¥å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡å­é—®é¢˜ï¼ˆå­æ ‘ï¼‰çš„ç­”æ¡ˆæ¨å¯¼å‡ºåŸé—®é¢˜çš„ç­”æ¡ˆ**ï¼Ÿ  
	å¦‚æœå¯ä»¥ï¼Œå†™å‡ºè¿™ä¸ªé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå¹¶å……åˆ†åˆ©ç”¨è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™å«ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€ç»´æ¨¡å¼ã€‚

æ— è®ºä½¿ç”¨å“ªç§æ€ç»´æ¨¡å¼ï¼Œéƒ½éœ€è¦æ€è€ƒï¼š

**å¦‚æœå•ç‹¬æŠ½å‡ºä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹ï¼Œå®ƒéœ€è¦åšä»€ä¹ˆäº‹æƒ…ï¼Ÿéœ€è¦åœ¨ä»€ä¹ˆæ—¶å€™ï¼ˆå‰/ä¸­/ååºä½ç½®ï¼‰åš**ï¼Ÿ

### 1. å‰ä¸­ååº:stopwatch: 

äºŒå‰æ ‘å‰ä¸­ååºéå†æ¡†æ¶ï¼š

```java
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // å‰åºä½ç½®
    traverse(root.left);
    // ä¸­åºä½ç½®
    traverse(root.right);
    // ååºä½ç½®
}
```

### 2. å±‚åº:construction: 

äºŒå‰æ ‘å±‚åºéå†æ¡†æ¶ï¼š

```java
void levelTraverse(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    // ä»ä¸Šåˆ°ä¸‹éå†äºŒå‰æ ‘çš„æ¯ä¸€å±‚
    while (!q.isEmpty()) {
        int sz = q.size();
        // ä»å·¦åˆ°å³éå†æ¯ä¸€å±‚çš„æ¯ä¸ªèŠ‚ç‚¹
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            // å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—
            if (cur.left != null) {
                q.offer(cur.left);
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
    }
}
```

### 3. å®æˆ˜:postbox: 

#### 3.1 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

:point_right:[**LeetCode104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦**](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/) 

:alien:**æ€è·¯è§£æï¼š** 

- ã€Œéå†ã€

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;							// è®°å½•æœ€å¤§æ·±åº¦
    int depth = 0;							// è®°å½•éå†åˆ°çš„èŠ‚ç‚¹çš„æ·±åº¦
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    void traverse(TreeNode* root) {			// äºŒå‰æ ‘éå†æ¡†æ¶
        if(root==nullptr) {
            return;
        }
        // å‰åºä½ç½®
        depth++;
        if(root->left==nullptr && root->right==nullptr) {
            res = depth>res ? depth : res;	// åˆ°è¾¾å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°æœ€å¤§æ·±åº¦
        }
        traverse(root->left);
        traverse(root->right);
        // ååºä½ç½®
        depth--;
    }
};
```

- ã€Œåˆ†è§£é—®é¢˜ã€

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) {
            return 0;
        }
        //è®¡ç®—å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        //æ¯”è¾ƒå·¦å³å­æ ‘ï¼Œè¿”å›è¾ƒå¤§è€…+1
        int res = (leftMax>rightMax ? leftMax : rightMax) + 1;
        return res;
    }
};
```

#### 3.2 äºŒå‰æ ‘çš„å‰åºéå†

:point_right:[**LeetCode144. äºŒå‰æ ‘çš„å‰åºéå†**](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)  

:alien:**æ€è·¯è§£æï¼š** 

- äºŒå‰æ ‘çš„å‰åºéå†ç»“æœ = æ ¹èŠ‚ç‚¹ + å·¦å­æ ‘çš„å‰åºéå†ç»“æœ + å³å­æ ‘çš„å‰åºéå†ç»“æœ

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:   
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res; 
        if(root==nullptr) {
            return res;
        }
        //æ ¹èŠ‚ç‚¹
        res.push_back(root->val);
        //å·¦å­æ ‘
        vector<int> left = preorderTraversal(root->left);
        res.insert(res.end(),left.begin(),left.end());
        //å³å­æ ‘
        vector<int> right = preorderTraversal(root->right);
        res.insert(res.end(),right.begin(),right.end());
        return res;
    }
};
```

#### 3.3 äºŒå‰æ ‘çš„ç›´å¾„

:point_right:[**LeetCode543. äºŒå‰æ ‘çš„ç›´å¾„**](https://leetcode.cn/problems/diameter-of-binary-tree/) 

:alien:**æ€è·¯è§£æï¼š** 

- äºŒå‰æ ‘çš„ã€Œç›´å¾„ã€é•¿åº¦ï¼Œå°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ä¹‹å’Œ

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // è®°å½•æœ€å¤§ç›´å¾„çš„é•¿åº¦
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        // å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¡ç®—ç›´å¾„ï¼Œæ±‚æœ€å¤§ç›´å¾„
        traverse(root);
        return maxDiameter;
    }
    void traverse(TreeNode* root){
        if(root==nullptr){
            return;
        }
        // å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¡ç®—ç›´å¾„
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        int Diameter = left + right;
        // æ›´æ–°å…¨å±€æœ€å¤§ç›´å¾„
        maxDiameter = Diameter>maxDiameter ? Diameter : maxDiameter;
        traverse(root->left);
        traverse(root->right);
    }
    // è®¡ç®—äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    int maxDepth(TreeNode* root){
        if(root==nullptr){
            return 0;
        }
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        return (left>right?left:right) + 1;
    }
};
```

ã€:triangular_flag_on_post:ã€‘ä¼˜åŒ–ï¼šå‰åºä½ç½®æ— æ³•è·å–å­æ ‘ä¿¡æ¯  
						è®¡ç®—ã€Œç›´å¾„ã€çš„é€»è¾‘æ”¾åœ¨ååºä½ç½®ï¼Œå¯æé«˜ä»£ç è¿è¡Œé€Ÿåº¦  
						O(N^2) $\rightarrow$ O(N)

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        maxDepth(root);
        return maxDiameter;
    }
    int maxDepth(TreeNode* root){
        if(root==nullptr){
            return 0;
        }
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        // ååºä½ç½®ï¼Œé¡ºä¾¿è®¡ç®—æœ€å¤§ç›´å¾„
        int Diameter = left + right;
        maxDiameter = Diameter>maxDiameter ? Diameter : maxDiameter;
        return (left>right?left:right) + 1;
    }
};
```

#### 3.4 ç¿»è½¬äºŒå‰æ ‘

:point_right:[**LeetCode226. ç¿»è½¬äºŒå‰æ ‘**](https://leetcode.cn/problems/invert-binary-tree/description/) 

:alien:**æ€è·¯è§£æï¼š** 

- ã€Œéå†ã€

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        traverse(root);
        return root;
    }
    void traverse(TreeNode* root) {
        if(root==nullptr) {
            return;
        }
        //å‰åºä½ç½®ï¼Œäº¤æ¢å·¦å³å­èŠ‚ç‚¹
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        
        traverse(root->left);
        traverse(root->right);
    }
};
```

- ã€Œåˆ†è§£é—®é¢˜ã€

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) {
            return nullptr;
        }
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
		//äº¤æ¢å·¦å³å­èŠ‚ç‚¹
        root->left = right;
        root->right = left;
        return root;
    }
};
```

#### 3.5 å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

:point_right:[**LeetCode116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ**](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/) 

:alien:**æ€è·¯è§£æï¼š** 

- ä¸‰å‰æ ‘ã€Œéå†ã€

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if(root==nullptr) {
            return nullptr;
        }
        traverse(root->left, root->right);
        return root;
    }
    void traverse(Node* node1, Node* node2) {
        if(node1==nullptr || node2==nullptr) {
            return;
        }
        // å°†ä¼ å…¥çš„ä¸¤ä¸ªèŠ‚ç‚¹ç©¿èµ·æ¥
        node1->next = node2;
        // è¿æ¥ç›¸åŒçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        // è¿æ¥è·¨è¶Šçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
        traverse(node1->right, node2->left);
    }
};
```

#### 3.6 äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

:point_right:[**LeetCode114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨**](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/)  

:alien:**æ€è·¯è§£æï¼š** 

- ã€Œåˆ†è§£é—®é¢˜ã€

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        if(root==nullptr) {
            return;
        }
        flatten(root->left);
        flatten(root->right);

        TreeNode* left = root->left;
        TreeNode* right = root->right;

        root->left = nullptr;
        root->right = left;

        TreeNode* r = root;
        while(r->right!=nullptr) {
            r = r->right;
        }
        r->right = right;
    }
};
```

ã€:microscope:ã€‘ã€Œéå†ã€éœ€è¦åˆ›å»ºæ–°çš„é“¾è¡¨

---
> âœï¸ [é‚¢ç¦å‡¯ (xfkcode@github)](https://github.com/xfkcode)  
> ğŸ“… **å†™äº2023å¹´2æœˆ** 
