# äºŒå‰æ ‘:cactus: 

äºŒå‰æ ‘è§£é¢˜çš„æ€ç»´æ¨¡å¼åˆ†ä¸¤ç±»ï¼š

**1. æ˜¯å¦å¯ä»¥é€šè¿‡éå†ä¸€éäºŒå‰æ ‘å¾—åˆ°ç­”æ¡ˆ**ï¼Ÿ  
	å¦‚æœå¯ä»¥ï¼Œç”¨ä¸€ä¸ª `traverse` å‡½æ•°é…åˆå¤–éƒ¨å˜é‡æ¥å®ç°ï¼Œè¿™å«ã€Œéå†ã€çš„æ€ç»´æ¨¡å¼ã€‚

**2. æ˜¯å¦å¯ä»¥å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡å­é—®é¢˜ï¼ˆå­æ ‘ï¼‰çš„ç­”æ¡ˆæ¨å¯¼å‡ºåŸé—®é¢˜çš„ç­”æ¡ˆ**ï¼Ÿ  
	å¦‚æœå¯ä»¥ï¼Œå†™å‡ºè¿™ä¸ªé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå¹¶å……åˆ†åˆ©ç”¨è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™å«ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€ç»´æ¨¡å¼ã€‚

æ— è®ºä½¿ç”¨å“ªç§æ€ç»´æ¨¡å¼ï¼Œéƒ½éœ€è¦æ€è€ƒï¼š

**å¦‚æœå•ç‹¬æŠ½å‡ºä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹ï¼Œå®ƒéœ€è¦åšä»€ä¹ˆäº‹æƒ…ï¼Ÿéœ€è¦åœ¨ä»€ä¹ˆæ—¶å€™ï¼ˆå‰/ä¸­/ååºä½ç½®ï¼‰åš**ï¼Ÿ

### 1. å‰ä¸­ååº:stopwatch: 

äºŒå‰æ ‘éå†æ¡†æ¶ï¼š

```c++
void traverse(TreeNode root) {
    if (root == nullptr) {
        return;
    }
    // å‰åºä½ç½®
    traverse(root.left);
    // ä¸­åºä½ç½®
    traverse(root.right);
    // ååºä½ç½®
}
```

#### 1.1 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

:point_right:[**LeetCode104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦**](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/) 

:alien:**æ€è·¯è§£æï¼š** 

- ã€Œéå†ã€

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;							// è®°å½•æœ€å¤§æ·±åº¦
    int depth = 0;							// è®°å½•éå†åˆ°çš„èŠ‚ç‚¹çš„æ·±åº¦
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    void traverse(TreeNode* root) {			// äºŒå‰æ ‘éå†æ¡†æ¶
        if(root==nullptr) {
            return;
        }
        // å‰åºä½ç½®
        depth++;
        if(root->left==nullptr && root->right==nullptr) {
            res = depth>res ? depth : res;	// åˆ°è¾¾å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°æœ€å¤§æ·±åº¦
        }
        traverse(root->left);
        traverse(root->right);
        // ååºä½ç½®
        depth--;
    }
};
```

- ã€Œåˆ†è§£é—®é¢˜ã€

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) {
            return 0;
        }
        //è®¡ç®—å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        //æ¯”è¾ƒå·¦å³å­æ ‘ï¼Œè¿”å›è¾ƒå¤§è€…+1
        int res = (leftMax>rightMax ? leftMax : rightMax) + 1;
        return res;
    }
};
```

#### 1.2 äºŒå‰æ ‘çš„å‰åºéå†

:point_right:[**LeetCode144. äºŒå‰æ ‘çš„å‰åºéå†**](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)  

:alien:**æ€è·¯è§£æï¼š** 

- äºŒå‰æ ‘çš„å‰åºéå†ç»“æœ = æ ¹èŠ‚ç‚¹ + å·¦å­æ ‘çš„å‰åºéå†ç»“æœ + å³å­æ ‘çš„å‰åºéå†ç»“æœ

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:   
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res; 
        if(root==nullptr) {
            return res;
        }
        res.push_back(root->val);
        vector<int> left = preorderTraversal(root->left);
        res.insert(res.end(),left.begin(),left.end());
        vector<int> right = preorderTraversal(root->right);
        res.insert(res.end(),right.begin(),right.end());
        return res;
    }
};
```

#### 1.3 äºŒå‰æ ‘çš„ç›´å¾„

:point_right:[**LeetCode543. äºŒå‰æ ‘çš„ç›´å¾„**](https://leetcode.cn/problems/diameter-of-binary-tree/) 

:alien:**æ€è·¯è§£æï¼š** 

- äºŒå‰æ ‘çš„ã€Œç›´å¾„ã€é•¿åº¦ï¼Œå°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ä¹‹å’Œ

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // è®°å½•æœ€å¤§ç›´å¾„çš„é•¿åº¦
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        // å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¡ç®—ç›´å¾„ï¼Œæ±‚æœ€å¤§ç›´å¾„
        traverse(root);
        return maxDiameter;
    }
    void traverse(TreeNode* root){
        if(root==nullptr){
            return;
        }
        // å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¡ç®—ç›´å¾„
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        int Diameter = left + right;
        // æ›´æ–°å…¨å±€æœ€å¤§ç›´å¾„
        maxDiameter = Diameter>maxDiameter ? Diameter : maxDiameter;
        traverse(root->left);
        traverse(root->right);
    }
    // è®¡ç®—äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
    int maxDepth(TreeNode* root){
        if(root==nullptr){
            return 0;
        }
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        return (left>right?left:right) + 1;
    }
};
```

ã€:triangular_flag_on_post:ã€‘ä¼˜åŒ–ï¼šå‰åºä½ç½®æ— æ³•è·å–å­æ ‘ä¿¡æ¯  
						è®¡ç®—ã€Œç›´å¾„ã€çš„é€»è¾‘æ”¾åœ¨ååºä½ç½®ï¼Œå¯æé«˜ä»£ç è¿è¡Œé€Ÿåº¦  
						O(N^2) $\rightarrow$ O(N)

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        maxDepth(root);
        return maxDiameter;
    }
    int maxDepth(TreeNode* root){
        if(root==nullptr){
            return 0;
        }
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        // ååºä½ç½®ï¼Œé¡ºä¾¿è®¡ç®—æœ€å¤§ç›´å¾„
        int Diameter = left + right;
        maxDiameter = Diameter>maxDiameter ? Diameter : maxDiameter;
        return (left>right?left:right) + 1;
    }
};
```

#### 1.4 ç¿»è½¬äºŒå‰æ ‘

:point_right:[**LeetCode226. ç¿»è½¬äºŒå‰æ ‘**](https://leetcode.cn/problems/invert-binary-tree/description/) 

:alien:**æ€è·¯è§£æï¼š** 

- ã€Œéå†ã€

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        traverse(root);
        return root;
    }
    void traverse(TreeNode* root) {
        if(root==nullptr) {
            return;
        }
        //å‰åºä½ç½®ï¼Œäº¤æ¢å·¦å³å­èŠ‚ç‚¹
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        
        traverse(root->left);
        traverse(root->right);
    }
};
```

- ã€Œåˆ†è§£é—®é¢˜ã€

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) {
            return nullptr;
        }
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
		//äº¤æ¢å·¦å³å­èŠ‚ç‚¹
        root->left = right;
        root->right = left;
        return root;
    }
};
```





---
> âœï¸ [é‚¢ç¦å‡¯ (xfkcode@github)](https://github.com/xfkcode)  
> ğŸ“… **å†™äº2023å¹´2æœˆ** 
