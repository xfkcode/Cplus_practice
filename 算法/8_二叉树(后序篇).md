# 8_äºŒå‰æ ‘(ååºç¯‡):ticket: 

### ååº:back: 

**å‰åºä½ç½®çš„ä»£ç åªèƒ½ä»å‡½æ•°å‚æ•°ä¸­è·å–çˆ¶èŠ‚ç‚¹ä¼ é€’æ¥çš„æ•°æ®ï¼Œ**  
**è€Œååºä½ç½®çš„ä»£ç ä¸ä»…å¯ä»¥è·å–å‚æ•°æ•°æ®ï¼Œè¿˜å¯ä»¥è·å–åˆ°å­æ ‘é€šè¿‡å‡½æ•°è¿”å›å€¼ä¼ é€’å›æ¥çš„æ•°æ®ã€‚**

#### å¯»æ‰¾é‡å¤çš„å­æ ‘:cactus: 

:point_right:[**LeetCode652.å¯»æ‰¾é‡å¤çš„å­æ ‘**](https://leetcode.cn/problems/find-duplicate-subtrees/)   

:alien:**æ€è·¯è§£æï¼š** 

- åºåˆ—åŒ–å”¯ä¸€è¡¨ç¤º
  å‰åºéå†

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        return {repeat.begin(), repeat.end()};
    }

    string dfs(TreeNode* node) {
        if (!node) {
            return "";
        }
        string serial = to_string(node->val) + "(" + dfs(node->left) + ")(" + dfs(node->right) + ")";
        if (auto it = seen.find(serial); it != seen.end()) {
            repeat.insert(it->second);
        }
        else {
            seen[serial] = node;
        }
        return serial;
    }

private:
    unordered_map<string, TreeNode*> seen;
    unordered_set<TreeNode*> repeat;
};
```

:alien:**æ€è·¯è§£æï¼š** 

- ä¸‰å…ƒç»„å”¯ä¸€è¡¨ç¤º

  ç”¨ä¸€ä¸ªä¸‰å…ƒç»„ç›´æ¥è¡¨ç¤ºä¸€æ£µå­æ ‘ï¼Œå³ (x,l,r)ï¼Œå®ƒä»¬åˆ†åˆ«è¡¨ç¤ºï¼š

  æ ¹èŠ‚ç‚¹çš„å€¼ä¸º xï¼›å·¦å­æ ‘çš„åºå·ä¸º lï¼›å³å­æ ‘çš„åºå·ä¸º r.


```C++
class Solution {
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        return {repeat.begin(), repeat.end()};
    }

    int dfs(TreeNode* node) {
        if (!node) {
            return 0;
        }
        auto tri = tuple{node->val, dfs(node->left), dfs(node->right)};
        if (auto it = seen.find(tri); it != seen.end()) {
            repeat.insert(it->second.first);
            return it->second.second;
        }
        else {
            seen[tri] = {node, ++idx};
            return idx;
        }
    }

private:
    static constexpr auto tri_hash = [fn = hash<int>()](const tuple<int, int, int>& o) -> size_t {
        auto&& [x, y, z] = o;
        return (fn(x) << 24) ^ (fn(y) << 8) ^ fn(z);
    };

    unordered_map<tuple<int, int, int>, pair<TreeNode*, int>, decltype(tri_hash)> seen{0, tri_hash};
    unordered_set<TreeNode*> repeat;
    int idx = 0;
};
```

:stopwatch:**5.4**  

---
> âœï¸ [é‚¢ç¦å‡¯ (xfkcode@github)](https://github.com/xfkcode)  
> ğŸ“… **å†™äº2023å¹´4æœˆ** 
