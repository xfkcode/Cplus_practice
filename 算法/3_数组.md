# 数组

在数组中并没有真正意义上的指针，但可以把索引当做数组中的指针，这样也可以在数组中施展双指针技巧

### 1. 快慢指针技巧

**快慢指针，就是两个指针同向而行，一快一慢** 

#### 1.1 删除有序数组中的重复项

:point_right:[**LeetCode26. 删除有序数组中的重复项**](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/) 

:alien:**思路解析：** 

- 让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就赋值给 `slow` 并让 `slow` 前进一步
- 当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是整个数组去重之后的结果

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size()==0){
            return 0;
        }
        int slow = 0;
        int fast = 0;
        while(fast<nums.size()){
            if(nums[slow]!=nums[fast]){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
};
```

【:ticket:】扩展链表 
             [**LeetCode83. 删除排序链表中的重复元素**](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/submissions/) 

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==nullptr){
            return nullptr;
        }
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast!=nullptr){
            if(fast->val!=slow->val){
                slow->next = fast; 
                slow = slow->next;
            }
            fast = fast->next; 
        }
        slow->next = nullptr;
        return head;
    }
};
```

#### 1.2 **原地删除指定元素** 

:point_right:[**LeetCode27. 移除元素**](https://leetcode.cn/problems/remove-element/description/) 

:alien:**思路解析：** 

- 如果 `fast` 遇到值为 `val` 的元素，则直接跳过，否则就赋值给 `slow` 指针，并让 `slow` 前进一步

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.size()==0){
            return 0;
        }
        int slow = 0;
        int fast = 0;
        while(fast<nums.size()){
            if(nums[fast]!=val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

- [x] 注意这里和有序数组去重的解法有一个细节差异  
  先给 `nums[slow]` 赋值然后再给 `slow++`，这样可以保证 `nums[0..slow-1]` 是不包含值为 `val` 的元素的，最后的结果数组长度就是 `slow` 

【:ticket:】扩展  
             [**LeetCode283. 移动零**](https://leetcode.cn/problems/move-zeroes/description/) 

:alien:**思路解析：** 

- 首先原地删除 `nums` 中的所有 0
- 再把后面的元素都赋值为 0 即可

```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;
        int fast = 0;
        while(fast<nums.size()){
            if(nums[fast]!=0){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        for(int i=slow;i<nums.size();i++){
            nums[i] = 0;
        }
    }
};
```

### 2. 左右指针技巧

#### 2.1 二分查找

```C++
int binarySearch(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size()-1;
    while(left<=right){
        int mid = (left+right)/2;
        if(nums[mid]==target)
            return mid;
        else if(nums[mid]<target)
            left = mid + 1;
        else if(nums[mid]>target)
            right = mid - 1;
    }
    return -1;
}
```

- [x] 时间复杂度 `O(log2N)`   
  空间复杂度 `O(1)`   

#### 2.2 两数之和

:point_right:[**LeetCode167. 两数之和 II - 输入有序数组**](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/) 

:alien:**思路解析：** 

- 类似二分查找
- 通过调节 `left` 和 `right` 就可以调整 `sum` 的大小

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;
        int right = numbers.size()-1;
        int sum;
        vector<int> ret;
        while(left<=right){
            sum = numbers[left] + numbers[right];
            if(sum==target){
                ret.push_back(left+1);
                ret.push_back(right+1);
                return ret;
            }
            else if(sum<target)
                left++;
            else if(sum>target)
                right--;
        }
        ret.push_back(-1);
        ret.push_back(-1);
        return ret;
    }
};
```



#### 2.3 反转数组



#### 2.4 回文串判断
