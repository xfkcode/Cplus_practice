# ç½‘ç»œç¼–ç¨‹(6)

## libevent

### åœ°åŸºevent_base

ä½¿ç”¨ libevent å‡½æ•°ä¹‹å‰éœ€è¦åˆ†é…ä¸€ä¸ªæˆ–å¤šä¸ª event_base ç»“æ„ä½“ï¼Œevent_base ç»“æ„ä½“ç›¸å½“äº epoll çº¢é»‘æ ‘çš„æ ¹èŠ‚ç‚¹   
æ¯ä¸ª event_baes ç»“æ„ä½“æŒæœ‰ä¸€ä¸ªäº‹ä»¶é›†åˆï¼Œå¯ä»¥æ£€æµ‹ä»¥ç¡®å®šå“ªä¸ªäº‹ä»¶æ˜¯æ¿€æ´»çš„  
æ¯ä¸ª event_base éƒ½æœ‰ä¸€ç§ç”¨äºæ£€æµ‹æŸç§äº‹ä»¶å·²ç»å°±ç»ªçš„â€œæ–¹æ³•â€ï¼ˆå›è°ƒå‡½æ•°ï¼‰

```C
struct event_base *event_base_new(void);
```

- å‡½æ•°è¯´æ˜ï¼šè·å¾— event_base ç»“æ„ä½“æŒ‡é’ˆ
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šè¿”å› event_base ç»“æ„ä½“æŒ‡é’ˆ
  - å¤±è´¥ï¼šè¿”å›NULL
- å‚æ•°è¯´æ˜ï¼švoid

```C
void event_base_free(struct event_base *base);
```

- å‡½æ•°è¯´æ˜ï¼šé‡Šæ”¾ event_base ç»“æ„ä½“æŒ‡é’ˆ
- è¿”å›å€¼ï¼švoid
- å‚æ•°è¯´æ˜ï¼ševent_base ç»“æ„ä½“æŒ‡é’ˆ

```C
int event_reinit(struct event_base *base);
```

- å‡½æ•°è¯´æ˜ï¼š  
  å¦‚æœæœ‰å­è¿›ç¨‹ï¼Œä¸”å­è¿›ç¨‹ä¹Ÿè¦ä½¿ç”¨ baseï¼Œåˆ™å­è¿›ç¨‹éœ€è¦å¯¹ event_base é‡æ–°åˆå§‹åŒ–ï¼Œæ­¤æ—¶éœ€è¦è°ƒç”¨ event_reinit å‡½æ•°
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šè¿”å› 0
  - å¤±è´¥ï¼šè¿”å› -1
- å‚æ•°è¯´æ˜ï¼š
  - `base` ï¼šç”± event_base_new è¿”å›çš„ event_base ç»“æ„ä½“æŒ‡é’ˆ

ã€:printer:ã€‘æŸ¥çœ‹å½“å‰ç³»ç»Ÿæ”¯æŒçš„libeventæ–¹æ³•  
		     æŸ¥çœ‹å½“å‰ä½¿ç”¨çš„æ–¹æ³•

```C
  1 //æµ‹è¯•å½“å‰ç³»ç»Ÿæ”¯æŒçš„libeventæ–¹æ³•å’Œå½“å‰ä½¿ç”¨çš„æ–¹æ³•
  2 #include <stdio.h>
  3 #include <string.h>
  4 #include <stdlib.h>
  5 #include <event2/event.h>
  6 
  7 int main()
  8 {
  9     int i = 0;
 10     //å½“å‰ç³»ç»Ÿæ”¯æŒçš„libeventæ–¹æ³•
 11     const char **p = event_get_supported_methods();
 12     while(p[i]!=NULL){
 13         printf("[%s] ", p[i++]);
 14     }
 15     printf("\n");
 16 
 17     //è·å–åœ°åŸºèŠ‚ç‚¹
 18     struct event_base *base = event_base_new();
 19     if(base==NULL){
 20         printf("event_base_new error\n");
 21         return -1;
 22     }
 23 
 24     //å½“å‰ä½¿ç”¨çš„æ–¹æ³•
 25     const char *pp = event_base_get_method(base);
 26     printf("[%s]\n", pp);
 27 
 28     //é‡Šæ”¾åœ°åŸºèŠ‚ç‚¹
 29     event_base_free(base);
 30 
 31     return 0;
 32 }

 >>>>æ‰§è¡Œç»“æœ
 [xfk@centos LIBEVENT]$ gcc -o event event.c -levent
 [xfk@centos LIBEVENT]$ ./event
 [epoll] [poll] [select] 
 [epoll]
```

### å¾ªç¯ç­‰å¾…event_loop

```C
int event_base_loop(struct event_base *base, int flags);
```

- å‡½æ•°è¯´æ˜ï¼šè¿›å…¥å¾ªç¯ç­‰å¾…äº‹ä»¶
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šè¿”å› `0` 
  - é”™è¯¯ï¼šè¿”å› `-1`
  - `1` ï¼šæ²¡æœ‰äº‹ä»¶å‘ç”Ÿæˆ–æ¿€æ´»ï¼Œé€€å‡º
- å‚æ•°è¯´æ˜ï¼š
  - `base` ï¼šç”± event_base_new è¿”å›çš„ event_base ç»“æ„ä½“æŒ‡é’ˆ
  - `flags` ï¼š
    - `#define EVLOOP_ONCE 0x01`   
      æŒ‡è§¦å‘ä¸€æ¬¡ï¼Œå¦‚æœäº‹ä»¶æ²¡æœ‰è¢«è§¦å‘ï¼Œé˜»å¡ç­‰å¾…
    - `#define EVLOOP_NONBLOCK 0x02`   
      éé˜»å¡æ–¹å¼æ£€æµ‹äº‹ä»¶æ˜¯å¦è¢«è§¦å‘ï¼Œä¸ç®¡äº‹ä»¶è§¦å‘ä¸å¦ï¼Œéƒ½ä¼šç«‹å³è¿”å›

```C
int event_base_dispatch(struct event_base *base);
```

- å‡½æ•°è¯´æ˜ï¼šè¿›å…¥å¾ªç¯ç­‰å¾…äº‹ä»¶
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šè¿”å› `0` 
  - é”™è¯¯ï¼šè¿”å› `-1`
  - `1` ï¼šæ²¡æœ‰äº‹ä»¶å‘ç”Ÿæˆ–æ¿€æ´»ï¼Œé€€å‡º
- å‚æ•°è¯´æ˜ï¼š
  - `base` ï¼šç”± event_base_new è¿”å›çš„ event_base ç»“æ„ä½“æŒ‡é’ˆ

```C
struct timeval{
    long tv_sec;
    long tv_usec;
};
int event_base_loopexit(struct event_base *base, const struct timeval *tv);
int event_base_loopbreak(struct event_base *);
```

ã€:stopwatch:ã€‘ç»ˆæ­¢å¾ªç¯  
		     `event_base_loopexit` å¦‚æœäº‹ä»¶è§¦å‘ï¼Œå›è°ƒå‡½æ•°è¿˜æœªæ‰§è¡Œå®Œï¼Œåˆ™å›è°ƒå‡½æ•°æ‰§è¡Œç»“æŸåç»ˆæ­¢å¾ªç¯ï¼ˆå¦‚æœtvéNULLï¼Œåˆ™ç­‰å¾…è®¾ç½®çš„æ—¶é—´tvåç«‹å³ç»ˆæ­¢å¾ªç¯ï¼‰  
		     `event_base_loopbreak` ç«‹å³ç»ˆæ­¢å¾ªç¯

### äº‹ä»¶é©±åŠ¨event

```C
typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);
struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);
void event_free(struct event *ev);
```

- å‡½æ•°1è¯´æ˜ï¼šåˆ›å»º event ç»“æ„ä½“æŒ‡é’ˆï¼ŒæŒ‡å®šåœ°åŸº baseï¼Œæ–‡ä»¶æè¿°ç¬¦ã€äº‹ä»¶ã€å›è°ƒå‡½æ•°ä»¥åŠå›è°ƒå‡½æ•°å‚æ•°  
  å‡½æ•°2è¯´æ˜ï¼šé‡Šæ”¾ event ç»“æ„ä½“æŒ‡é’ˆ
- è¿”å›å€¼ï¼šè¿”å› event ç»“æ„ä½“æŒ‡é’ˆ
- å‚æ•°è¯´æ˜ï¼š
  - `base` ï¼šç”± event_base_new è¿”å›çš„ event_base ç»“æ„ä½“æŒ‡é’ˆ
  - `fd` ï¼šæ–‡ä»¶æè¿°ç¬¦
  - `events` ï¼šç›‘å¬äº‹ä»¶
    - `#define EV_READ     0x02` è¯»äº‹ä»¶
    - `#define EV_WRITE    0x04` å†™äº‹ä»¶
    - `#define EV_SIGNAL   0x08` ä¿¡å·äº‹ä»¶
    - `#define EV_PERSIST  0x10` å‘¨æœŸæ€§è§¦å‘
    - `#define EV_ET       0x20` è¾¹ç¼˜è§¦å‘
  - `cb` ï¼šå›è°ƒå‡½æ•°
  - `arg` ï¼šå›è°ƒå‡½æ•°å‚æ•°

```C
int event_add(struct event *ev, const struct timeval *timeout);
int event_del(struct event *ev);
```

- å‡½æ•°1è¯´æ˜ï¼šä¸Šåœ°åŸº  
  å‡½æ•°2è¯´æ˜ï¼šä¸‹åœ°åŸº

### libeventï¼šserver/clientå¼€å‘æµç¨‹(TCP)

ã€**æœåŠ¡ç«¯server**:computer:ã€‘

```C
struct event_base *base;
struct event *Event[1024];

void readcb(evutil_socket_t fd, short events, void *arg){
    int i;
    int n;
    char buf[1024];
    struct event *ev = (struct event *)arg;
    memset(buf, 0x00, sizeof(buf));
    n = read(fd, buf, sizeof(buf));
    if(n<=0){
        perror("read error or client close\n");
        for(i=0;i<1024;i++){
        	if(Event[i]==ev){
            	Event[i] = NULL;
                break;
            }
        }
        event_del(ev);
        event_free(ev);
        close(fd);
        return;
    }
    printf("n==[%d],buf==[%s]\n", n, buf);
    for(i=0;i<n;i++){
        buf[i] = toupper(buf[i]);
    }
    write(fd, buf, n);
}

void conncb(evutil_socket_t fd, short events, void *arg){
    int cfd = accpet(fd, NULL, NULL);
    if(cfd<0){
        perror("accept error\n");
        return;
    }
    int i;
    for(i=0;i<1024;i++){
        if(Event[i]==NULL) break;
    }
    Event[i] = event_new(base, cfd, EV_READ|EV_PERSIST, readcb, Event[i]);
    event_add(Event[i], NULL);
}

1	åˆ›å»ºsocket
2	ç«¯å£å¤ç”¨setsockopt
3	ç»‘å®šbind  
4	ç›‘å¬listen
5	åˆ›å»ºåœ°åŸº
    base = event_base_new();
6	åˆ›å»ºlfdå¯¹åº”çš„event
    Event[1024] = event_new(base, lfd, EV_READ|EV_PERSIST, conncb, NULL);
7	ä¸Šåœ°åŸº
    event_add(Event[1024], NULL);
8	äº‹ä»¶å¾ªç¯
    event_base_dispatch(base);
9	é‡Šæ”¾èµ„æº
    event_free(Event[1024]);
	event_base_free(base);
10  å…³é—­
    close(lfd);
```

ã€:pill:**TEST**ã€‘

```C
  1 //libevent:serveræœåŠ¡ç«¯æµ‹è¯•
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 #include <event2/event.h>
 11 
 12 struct event_base *base;
 13 struct event *Event[1024];
 14 
 15 void readcb(evutil_socket_t fd, short events, void *arg){
 16     int i;
 17     int n;
 18     char buf[1024];
 19     struct event *ev = (struct event *)arg;
 20     memset(buf, 0x00, sizeof(buf));
 21     n = read(fd, buf, sizeof(buf));
 22     if(n<=0){
 23         perror("read error or client close\n");
 24         for(i=0;i<1024;i++){
 25             if(Event[i]==ev){
 26                 Event[i] = NULL;
 27                 break;
 28             }
 29         }
 30         event_del(ev);
 31         event_free(ev);
 32         close(fd);
 33         return;
 34     }
 35     printf("n==[%d],buf==[%s]\n", n, buf);
 36     for(i=0;i<n;i++){
 37         buf[i] = toupper(buf[i]);
 38     }
 39     write(fd, buf, n);
 40 }
 41 
 42 void conncb(evutil_socket_t fd, short events, void *arg){
 43     int cfd = accept(fd, NULL, NULL);
 44     if(cfd<0){
 45         perror("accept error\n");
 46         return;
 47     }
 48     int i;
 49     for(i=0;i<1024;i++){
 50         if(Event[i]==NULL) break;
 51     }
 52     Event[i] = event_new(base, cfd, EV_READ|EV_PERSIST, readcb, Event[i]);
 53     event_add(Event[i], NULL);
 54 }
 55 
 56 int main()
 57 {
 58     //åˆ›å»ºsocket
 59     int lfd = socket(AF_INET, SOCK_STREAM, 0);
 60     if(lfd<0){
 61         perror("socket error\n");
 62         return -1;
 63     }
 64     //ç«¯å£å¤ç”¨
 65     int opt = 1;
 66     setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
 67     //ç»‘å®š
 68     struct sockaddr_in serv;
 69     bzero(&serv, sizeof(serv));
 70     serv.sin_family = AF_INET;
 71     serv.sin_port = htons(8888);
 72     serv.sin_addr.s_addr = htonl(INADDR_ANY);
 73     int ret = bind(lfd, (struct sockaddr*)&serv, sizeof(serv));
 74     if(ret<0){
 75         perror("bind error\n");
 76         return -1;
 77     }
 78     //ç›‘å¬
 79     listen(lfd, 128);
 80     //åˆ›å»ºåœ°åŸº  
 81     base = NULL;
 82     base = event_base_new();
 83     //åˆ›å»ºlfdå¯¹åº”çš„event
 84     int i;
 85     for(i=0;i<1024;i++) Event[i] = NULL;
 86     Event[1024] = event_new(base, lfd, EV_READ|EV_PERSIST, conncb, NULL);
 87     //ä¸Šåœ°åŸº
 88     event_add(Event[1024], NULL);
 89     //äº‹ä»¶å¾ªç¯
 90     event_base_dispatch(base);
 91     //é‡Šæ”¾èµ„æº
 92     event_free(Event[1024]);
 93     event_base_free(base);
 94     //å…³é—­
 95     close(lfd);
 96     return 0;
 97 }
     
 >>>>æ‰§è¡Œç»“æœ
 [xfk@centos LIBEVENT]$ ./server
 n==[4],buf==[xfk
 ]
 n==[3],buf==[tq
 ]
 [xfk@centos ~]$ nc 127.1 8888
 xfk
 XFK
 [xfk@centos ~]$ nc 127.1 8888
 tq
 TQ
```

ã€:warning:ã€‘ : Success  
         	 Segmentation fault (core dumped)  
			  å®¢æˆ·ç«¯é€€å‡ºæŠ¥é”™:question: `event_del(ev);` 

ã€**å®¢æˆ·ç«¯client**:iphone:ã€‘

```C
```

ã€:pill:**TEST**ã€‘

```C
```



### sampleï¼šhello-world.c

```C
/*
  This example program provides a trivial server program that listens for TCP
  connections on port 9995.  When they arrive, it writes a short message to
  each client connection, and closes each connection once it is flushed.

  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).
*/

#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#ifndef _WIN32
#include <netinet/in.h>
# ifdef _XOPEN_SOURCE_EXTENDED
#  include <arpa/inet.h>
# endif
#include <sys/socket.h>
#endif

#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/listener.h>
#include <event2/util.h>
#include <event2/event.h>

static const char MESSAGE[] = "Hello, World!\n";

static const int PORT = 9995;

static void listener_cb(struct evconnlistener *, evutil_socket_t,
    struct sockaddr *, int socklen, void *); 
static void conn_writecb(struct bufferevent *, void *); 
static void conn_eventcb(struct bufferevent *, short, void *); 
static void signal_cb(evutil_socket_t, short, void *); 

int
main(int argc, char **argv)
{
    struct event_base *base;
    struct evconnlistener *listener;
    struct event *signal_event;

    struct sockaddr_in sin = {0};
#ifdef _WIN32
    WSADATA wsa_data;
    WSAStartup(0x0201, &wsa_data);
#endif

    base = event_base_new();
    if (!base) {
        fprintf(stderr, "Could not initialize libevent!\n");
        return 1;
    }

    sin.sin_family = AF_INET;
    sin.sin_port = htons(PORT);

    listener = evconnlistener_new_bind(base, listener_cb, (void *)base,
        LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1,
        (struct sockaddr*)&sin,
        sizeof(sin));

    if (!listener) {
        fprintf(stderr, "Could not create a listener!\n");
        return 1;
    }

    signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base);

    if (!signal_event || event_add(signal_event, NULL)<0) {
        fprintf(stderr, "Could not create/add a signal event!\n");
        return 1;
    }

    event_base_dispatch(base);

    evconnlistener_free(listener);
    event_free(signal_event);
    event_base_free(base);

    printf("done\n");
    return 0;
}

static void
listener_cb(struct evconnlistener *listener, evutil_socket_t fd,
    struct sockaddr *sa, int socklen, void *user_data)
{
    struct event_base *base = user_data;
    struct bufferevent *bev;

    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
    if (!bev) {
        fprintf(stderr, "Error constructing bufferevent!");
        event_base_loopbreak(base);
        return;
    }
    bufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL);
    bufferevent_enable(bev, EV_WRITE);
    bufferevent_disable(bev, EV_READ);

    bufferevent_write(bev, MESSAGE, strlen(MESSAGE));
}

static void
conn_writecb(struct bufferevent *bev, void *user_data)
{
    struct evbuffer *output = bufferevent_get_output(bev);
    if (evbuffer_get_length(output) == 0) {
        printf("flushed answer\n");
        bufferevent_free(bev);
    }
}

static void
conn_eventcb(struct bufferevent *bev, short events, void *user_data)
{
    if (events & BEV_EVENT_EOF) {
        printf("Connection closed.\n");
    } else if (events & BEV_EVENT_ERROR) {
        printf("Got an error on the connection: %s\n",
            strerror(errno));/*XXX win32*/
    }
    /* None of the other events can happen here, since we haven't enabled
     * timeouts */
    bufferevent_free(bev);
}

static void
signal_cb(evutil_socket_t sig, short events, void *user_data)
{
    struct event_base *base = user_data;
    struct timeval delay = { 2, 0 };

    printf("Caught an interrupt signal; exiting cleanly in two seconds.\n");

    event_base_loopexit(base, &delay);
}
```



---
> âœï¸ [é‚¢ç¦å‡¯ (xfkcode@github)](https://github.com/xfkcode)  
> ğŸ“… **å†™äº2023å¹´2æœˆ** 