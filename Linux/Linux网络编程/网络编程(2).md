# ç½‘ç»œç¼–ç¨‹(2)

## 1. ä¸‰æ¬¡æ¡æ‰‹å’Œå››æ¬¡æŒ¥æ‰‹

**TCPé¢å‘è¿æ¥çš„å®‰å…¨å¯é çš„ä¼ è¾“** 

ã€**å®¢æˆ·ç«¯client**ã€‘>>> `SYN:2000(0)          mss<1024>` >>>ã€**æœåŠ¡ç«¯server**ã€‘  
                              <<< `SYN:5000(0) ACK:2001 mss<1024>` <<<  
					          >>> `ACK:5001` >>>  
  **ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹è¿æ¥**  
					          >>> `Seq:2001(20)` >>>  
                              <<< `Seq:5001(50) ACK:2021` <<<  
							  >>> `ACK:5051` >>>  
  **æ•°æ®ä¼ è¾“**  
                              <<< `FIN:5051(0) ACK:2021` <<<  
						      >>> `ACK:5052` >>>   
							  >>> `FIN:2021(0) ACK:5052` >>>  
							  <<< `ACK:2022` <<<  
  **å››æ¬¡æŒ¥æ‰‹æ–­å¼€è¿æ¥**   

ã€:ticket:ã€‘SYN (è¯·æ±‚)ï¼šsynchronous  
                                   æœ¬èº«å 1ä½  
             ACK (ç¡®è®¤)ï¼šacknowledgement  
                                   ç¡®è®¤åºå· = å¯¹æ–¹å‘é€çš„å€¼ + æ•°æ®çš„é•¿åº¦   
             FIN  (ç»“æŸ)ï¼šfinish  
                                   æœ¬èº«å 1ä½

ã€:tractor:ã€‘ä¸‰æ¬¡æ— æ¡æ‰‹çŠ¶æ€  
		     å®¢æˆ·ç«¯ï¼šSYN_SENDï¼ˆconnectï¼‰  
             æœåŠ¡ç«¯ï¼šLISTENï¼ˆlistenï¼‰SYN_RCVD  
		     ä¸‰æ¬¡æ¡æ‰‹åï¼Œéƒ½å¤„äºESTABLISHEDçŠ¶æ€

ã€:triangular_flag_on_post:ã€‘å››æ¬¡æŒ¥æ‰‹çŠ¶æ€  
		    ä¸»åŠ¨å…³é—­æ–¹ï¼šFIN_WAIT_1>>>FIN_WAIT_2>>>TIME_WAIT  
		    è¢«åŠ¨å…³é—­æ–¹ï¼šCLOSE_WAIT>>>LAST_AC

## 2. æ»‘åŠ¨çª—å£

ä¸»è¦ä½œç”¨ï¼šè¿›è¡Œæµé‡æ§åˆ¶  
å¦‚æœå‘é€ç«¯å‘é€çš„é€Ÿåº¦è¾ƒå¿«ï¼Œæ¥æ”¶ç«¯æ”¶åˆ°æ•°æ®åå¤„ç†çš„é€Ÿåº¦è¾ƒæ…¢ï¼Œè€Œæ¥å—ç¼“å†²åŒºçš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œå°±ä¼šå¯¼è‡´æ¥æ”¶ç¼“å†²åŒºæ»¡è€Œä¸¢å¤±æ•°æ®

`win 4096` æ¥æ”¶ç¼“å­˜åŒºå¯ç”¨å¤§å°ï¼ŒåŠ¨æ€å˜åŒ–ï¼Œå³æ»‘åŠ¨çª—å£  
                   æ¥æ”¶åˆ°æ•°æ®åçª—å£å‡å°ï¼Œçª—å£å‡å°è‡³ 0 æ—¶åœæ­¢æ¥æ”¶ï¼Œè¯»å–æ•°æ®åçª—å£æ‰©å¤§

`mss 1024` ä¸€æ¬¡æœ€å¤§æ¥æ”¶æ•°æ®é‡

## 3. å‡½æ•°å°è£…æ€æƒ³

```C
void perr_exit(const char *s)
{
    perror(s);
    exit(-1);
}

int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)
{
    int n;
again:
    if ((n=accept(fd, sa, salenptr))<0){
        if ((error == ECONNABORTED)||(error == EINTR))
            goto again;
        else
            perr_exit("accept error");
    }
    return n;
}

int Bind(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;
    if ((n=bind(fd,sa,salen))<0)
        perr_exit("bind error");
    return n;
}

int Connect(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;
    if ((n=connect(fd, sa, salen))<0)
        perr_exit("connect error");
    return n;
}

int Listen(int fd, int backlog)
{
    int n;
    if ((n=listen(fd, backlog))<0)
        perr_exit("listen error");
    return n;
}

int Socket(int family, int type, int protocol)
{
    int n;
    if ((n=socket(family, type, protocol))<0)
        perr_exit("socket error");
    return n;
}

ssize_t Read(int fd, void *ptr, size_t nbytes)
{
    ssize_t n;
again:
    if ((n=read(fd, ptr, nbytes))==-1){
        if (error == EINTR)
            goto again;
        else
            return -1;
    }
    return n;
}

ssize_t Write(int fd, void *ptr, size_t nbytes)
{
    ssize_t n;
again:
    if ((n=write(fd, ptr, nbytes))==-1){
        if (error == EINTR)
            goto again;
        else
            return -1;
    }
    return n;
}

int Close(int fd)
{
    int n;
    if ((n=close(fd))==-1)
        perr_exit("close error");
    return n;
}
```

ã€:warning:ã€‘é˜»å¡å‡½æ•°åœ¨é˜»å¡æœŸé—´è‹¥æ”¶åˆ°ä¿¡å·ï¼Œä¼šè¢«ä¿¡å·ä¸­æ–­ï¼Œ`errno` è®¾ç½®ä¸º` EINTR`  
             è¿™ä¸ªé”™è¯¯ä¸åº”è¯¥çœ‹æˆä¸€ä¸ªé”™è¯¯

## 4. ç²˜åŒ…

ç²˜åŒ…ï¼šå¤šæ¬¡æ•°æ®å‘é€ï¼Œä¸Šä¸€æ¬¡æœªè¯»å®Œï¼Œå‰©ä½™éƒ¨åˆ†ä¸ä¸‹ä¸€æ¬¡ç›¸è¿ï¼Œæ— æ³•åŒºåˆ†ä¸¤æ¬¡å‘é€æ•°æ®åˆ†åˆ«æ˜¯å¤šå°‘

- è§£å†³æ–¹æ¡ˆ1  
  åŒ…å¤´+æ•°æ® `0010+0123456789`   
  åŒ…å¤´4Byteè¡¨ç¤ºæ•°æ®é•¿åº¦
- è§£å†³æ–¹æ¡ˆ2  
  æ·»åŠ ç»“å°¾æ ‡è®°  
  å¦‚åœ¨ç»“å°¾åŠ ä¸€ä¸ªå­—ç¬¦ `\n` `\$` ç­‰ï¼ˆè‡ªå®šä¹‰åè®®ï¼‰
- è§£å†³æ–¹æ¡ˆ3  
  æ•°æ®åŒ…å®šé•¿

## 5. é«˜å¹¶å‘æœåŠ¡å™¨

#### å¤šè¿›ç¨‹

ã€:boxing_glove:ã€‘æµç¨‹  
            çˆ¶è¿›ç¨‹æ¥æ”¶æ–°çš„è¿æ¥å¹¶å›æ”¶å­è¿›ç¨‹  
            å­è¿›ç¨‹å¤„ç†æ–°çš„è¿æ¥ï¼ˆæ”¶å‘æ•°æ®ï¼‰

```C
1	åˆ›å»ºsocket  
2	ç»‘å®šbind  
3	ç›‘å¬listen
    //é˜»å¡ SIGCHLD ä¿¡å·ï¼Œé˜²æ­¢ä¿¡å·æ³¨å†Œè¿˜æœªå®Œæˆå­è¿›ç¨‹æå‰é€€å‡º
4	while(1)
    {
    	//ç­‰å¾…æ–°çš„å®¢æˆ·ç«¯è¿æ¥
		cfd = accept();		//ä½¿ç”¨Accept()å°è£…å‡½æ•°å¿½ç•¥ä¿¡å·æ‰“æ–­
    	//fork
    	pid = fork();
    	if(pid<0)
        {
            exit(-1);
        }
    	else if(pid>0)		//çˆ¶è¿›ç¨‹
        {
            close(cfd);
            //SIGCHLD å›æ”¶å­è¿›ç¨‹
            //æ³¨å†Œ SIGCHLD ä¿¡å·å¤„ç†å‡½æ•°
            //è§£é™¤ SIGCHLD ä¿¡å·é˜»å¡
        }
    	else if(pid==0)		//å­è¿›ç¨‹
        {
            close(lfd);
            while(1)
            {
                //æ”¶å‘æ•°æ®
                n = read();	
                if(n<=0) break;
                write();
            }
            close(cfd);
            exit(0);		//é˜²æ­¢å­è¿›ç¨‹å†åˆ›å»ºå­è¿›ç¨‹
        }
    }
	close(lfd);
```

ã€:pill:**TEST**ã€‘

```C
  1 //æœåŠ¡ç«¯å¤šè¿›ç¨‹å¹¶å‘æµ‹è¯•
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 #include <signal.h>
 11 
 12 void waitchild(int signo)
 13 {
 14     pid_t wpid;
 15     while(1)
 16     {
 17         wpid = waitpid(-1, NULL, WNOHANG);
 18         if(wpid>0)
 19         {
 20             printf("child exit, wpid==[%d]\n", wpid);
 21         }
 22         else if(wpid==0 || wpid==-1)
 23         {
 24             break;
 25         }
 26     }
 27 }
 28 
 29 int main()
 30 {
 31     //åˆ›å»ºsocket
 32     int lfd = socket(AF_INET, SOCK_STREAM, 0);
 33     if(lfd<0)
 34     {
 35         perror("socket error");
 36         return -1;
 37     }
 38 
 39     //ç»‘å®šIPã€PORT
 40     struct sockaddr_in serv;
 41     bzero(&serv, sizeof(serv));
 42     serv.sin_family = AF_INET;
 43     serv.sin_port = htons(8888);
 44     serv.sin_addr.s_addr = htonl(INADDR_ANY);
 45     int ret = bind(lfd, (struct sockaddr*)&serv, sizeof(serv));
 46     if(ret<0)
 47     {
 48         perror("bind error");
 49         return -1;
 50     }
 51 
 52     //ç›‘å¬
 53     listen(lfd, 128);
 54 
 55     //é˜»å¡ SIGCHLD ä¿¡å·ï¼Œé˜²æ­¢ä¿¡å·æ³¨å†Œè¿˜æœªå®Œæˆå­è¿›ç¨‹æå‰é€€å‡º
 56     sigset_t mask;
 57     sigemptyset(&mask);
 58     sigaddset(&mask, SIGCHLD);
 59     sigprocmask(SIG_BLOCK, &mask, NULL);
 60 
 61     struct sockaddr_in client;
 62     socklen_t len;
 63     char sIP[16];
 64     int cfd;
 65     pid_t pid;
 66     while(1)
 67     {
 68         //ç­‰å¾…æ–°çš„å®¢æˆ·ç«¯è¿æ¥
 69         bzero(&client, sizeof(client));
 70         len = sizeof(client);
 71         memset(sIP, 0x00, sizeof(sIP));
 72 
 73         cfd = accept(lfd, (struct sockaddr*)&client, &len);
 74         printf("client-->IP:[%s],PORT:[%d]\n", inet_ntop(AF_INET, &client.sin_addr.s_addr, sIP, sizeof(sIP)),                                   ntohs(client.sin_port));
 75 
 76         //åˆ›å»ºå­è¿›ç¨‹
 77         pid = fork();
 78         if(pid<0)
 79         {
 80             exit(-1);
 81         }
 82         else if(pid>0)			//çˆ¶è¿›ç¨‹
 83         {
 84             close(cfd);
 85             //æ³¨å†Œ SIGCHLD ä¿¡å·å¤„ç†å‡½æ•°
 86             struct sigaction act;
 87             act.sa_handler = waitchild;
 88             sigemptyset(&act.sa_mask);
 89             act.sa_flags = 0;
 90             sigaction(SIGCHLD, &act, NULL);
 91 
 92             //è§£é™¤ SIGCHLD ä¿¡å·é˜»å¡
 93             sigprocmask(SIG_UNBLOCK, &mask, NULL);
 94         }
 95         else if(pid==0)			//å­è¿›ç¨‹
 96         {
 97             close(lfd);
 98             int i = 0;
 99             int n = 0;
100             char buf[1024];
101             while(1)
102             {
103                 //æ¥æ”¶æ•°æ®
104                 memset(buf, 0x00, sizeof(buf));
105                 n = read(cfd, buf, sizeof(buf));
106                 if(n<=0)
107                 {
108                     printf("read error or client close, n==[%d]\n", n);
109                     break;
110                 }
111                 printf("n==[%d],buf==[%s]\n", n, buf);
112 
113                 for(i=0;i<n;i++)
114                 {
115                     buf[i] = toupper(buf[i]);
116                 }
117                 //å‘é€æ•°æ®
118                 write(cfd, buf, n);
119             }
120             close(cfd);
121             exit(0);
122         }
123     }
124     close(lfd);
125     return 0;
126 }

>>>>æ‰§è¡Œç»“æœ
[xfk@centos SOCKET]$ ./server_fork 
client-->IP:[127.0.0.1],PORT:[41554]
n==[4],buf==[xfk
]
client-->IP:[127.0.0.1],PORT:[41556]
n==[3],buf==[tq
]
[xfk@centos ~]$ nc 127.1 8888
xfk
XFK
[xfk@centos ~]$ nc 127.1 8888
tq
TQ
```

ã€:warning:ã€‘å®¢æˆ·ç«¯é€€å‡ºä¼šä½¿å¾— `accept==-1` å¹¶ä¸”ä¸å†é˜»å¡:question: 

#### å¤šçº¿ç¨‹

ã€:atm:ã€‘æµç¨‹  
            ä¸»çº¿ç¨‹æ¥æ”¶æ–°çš„è¿æ¥  
            å­çº¿ç¨‹å¤„ç†æ–°çš„è¿æ¥ï¼ˆæ”¶å‘æ•°æ®ï¼‰

```C
1	åˆ›å»ºsocket
2	ç«¯å£å¤ç”¨
3	ç»‘å®šbind  
4	ç›‘å¬listen  
5	while(1)
    {
    	//ç­‰å¾…æ–°çš„å®¢æˆ·ç«¯è¿æ¥
		cfd = accept();		//ä½¿ç”¨Accept()å°è£…å‡½æ•°å¿½ç•¥ä¿¡å·æ‰“æ–­
    	//åˆ›å»ºå­çº¿ç¨‹
    	pthread_create(&threadID, NULL, thread_work, &cfd);
		//è®¾ç½®åˆ†ç¦»å±æ€§
    	pthread_detach();
    }
	close(lfd);
6	å­çº¿ç¨‹æ‰§è¡Œå‡½æ•°
    void *thread_work(void *arg)
	{
    	//è·å¾—å‚æ•°cfd
    	int cfd = *(int *)arg;
    	while(1)
        {
            //æ”¶å‘æ•°æ®
            n = read();	
            if(n<=0) break;
            write();
        }
    	close(cfd);
    	pthread_exit(NULL);
	}
7	ä¼˜åŒ–ï¼šåˆ›å»ºç»“æ„ä½“æ•°ç»„åˆ†åˆ«å­˜å‚¨å­çº¿ç¨‹ä¿¡æ¯ï¼Œä¸ä½¿ç”¨å…±äº«cfd
    #define MAX 1024
    typedef struct info
 	{
 	    int cfd;			//cfd==-1è¡¨ç¤ºå¯ç”¨
 	    int idx;
 	    pthread_t thread;
 	    struct sockaddr_in client;
 	}INFO;
	INFO thInfo[MAX];
```

ã€:pill:**TEST**ã€‘

```C
  1 //æœåŠ¡ç«¯å¤šçº¿ç¨‹å¹¶å‘æµ‹è¯•
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 #include <pthread.h>
 11 
 12 #define MAX 1024
 13 
 14 typedef struct info
 15 {
 16     int cfd;
 17     int idx;
 18     pthread_t thread;
 19     struct sockaddr_in client;
 20 }INFO;
 21 
 22 INFO thInfo[MAX];
 23 
 24 void *thread_work(void *arg)
 25 {
 26     INFO *p = (INFO *)arg;
 27 
 28     char sIP[16];
 29     memset(sIP, 0x00, sizeof(sIP));
 30     printf("client-->IP:[%s],PORT:[%d]\n", inet_ntop(AF_INET, &p->client.sin_addr.s_addr, sIP, sizeof(sIP)), 
               ntohs(p->client.sin_port));
 31 
 32     int i = 0;
 33     int n = 0;
 34     char buf[1024];
 35     while(1)
 36     {
 37         //æ¥æ”¶æ•°æ®
 38         memset(buf, 0x00, sizeof(buf));
 39         n = read(p->cfd, buf, sizeof(buf));
 40         if(n<=0)
 41         {
 42             printf("read error or client close, n==[%d]\n", n);
 43             break;
 44         }
 45         printf("n==[%d],buf==[%s]\n", n, buf);
 46 
 47         for(i=0;i<n;i++)
 48         {
 49             buf[i] = toupper(buf[i]);
 50         }
 51         //å‘é€æ•°æ®
 52         write(p->cfd, buf, n);
 53     }
 54     close(p->cfd);
 55     p->cfd = -1;
 56     pthread_exit(NULL);
 57 }
 58 
 59 void init_thInfo()
 60 {
 61     int i = 0;
 62     for(i=0;i<MAX;i++)
 63     {
 64         thInfo[i].cfd==-1;
 65     }
 66 }
 67 
 68 int findIndex()
 69 {
 70     int i = 0;
 71     for(i=0;i<MAX;i++)
 72     {
 73         if(thInfo[i].cfd==-1)
 74         {
 75             break;
 76         }
 77     }
 78     if(i==MAX)
 79     {
 80         return -1;
 81     }
 82     return i;
 83 }
 84 
 85 int main()
 86 {
 87     //åˆ›å»ºsocket
 88     int lfd = socket(AF_INET, SOCK_STREAM, 0);
 89     if(lfd<0)
 90     {
 91         perror("socket error");
 92         return -1;
 93     }
 94 
 95     //ç«¯å£å¤ç”¨
 96     int opt = 1;
 97     setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
 98 
 99     //ç»‘å®šIPã€PORT
100     struct sockaddr_in serv;
101     bzero(&serv, sizeof(serv));
102     serv.sin_family = AF_INET;
103     serv.sin_port = htons(8888);
104     serv.sin_addr.s_addr = htonl(INADDR_ANY);
105     int ret = bind(lfd, (struct sockaddr*)&serv, sizeof(serv));
106     if(ret<0)
107     {
108         perror("bind error");
109         return -1;
110     }
111 
112     //ç›‘å¬
113     listen(lfd, 128);
114 
115     //åˆå§‹åŒ–ç»“æ„ä½“æ•°ç»„
116     init_thInfo();
117 
118     
119     struct sockaddr_in client;
120     socklen_t len;
121     int cfd;
122     int idx;
123     while(1)
124     {
125         //ç­‰å¾…æ–°çš„å®¢æˆ·ç«¯è¿æ¥
126         bzero(&client, sizeof(client));
127         len = sizeof(client);
128         
129         cfd = accept(lfd, (struct sockaddr*)&client, &len);
130         
131         idx = findIndex();
132         if(idx==-1)
133         {
134             close(cfd);
135             continue;
136         }
137 		//èµ‹å€¼
138         thInfo[idx].cfd = cfd;
139         thInfo[idx].idx = idx;
140         memcpy(&thInfo[idx].client, &client, sizeof(client));
141 
142         //åˆ›å»ºå­çº¿ç¨‹
143         ret = pthread_create(&thInfo[idx].thread, NULL, thread_work, &thInfo[idx]);
144         if(ret!=0)
145         {
146             printf("cerate thread error:[%s]\n", strerror(ret));
147             exit(-1);
148         }
149         //è®¾ç½®åˆ†ç¦»å±æ€§
150         pthread_detach(thInfo[idx].thread);
151     }
152     close(lfd);
153     return 0;
154 }

```

---
> âœï¸ [é‚¢ç¦å‡¯ (xfkcode@github)](https://github.com/xfkcode)  
> ğŸ“… **å†™äº2023å¹´2æœˆ**  