# ç½‘ç»œç¼–ç¨‹(4)

## 1. å¤šè·¯IO-poll

#### pollå‡½æ•°

```C
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

- å‡½æ•°è¯´æ˜ï¼šselectç±»ä¼¼ï¼Œç›‘æ§å¤šè·¯IOï¼Œä½†pollä¸èƒ½è·¨å¹³å°
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼š`>0` è¿”å›æœ‰äº‹ä»¶å‘ç”Ÿç»“æ„ä½“æ•°é‡  
    					`=0` è¶…æ—¶æ²¡æœ‰äº‹ä»¶å‘ç”Ÿ
  - é”™è¯¯ï¼š-1ï¼Œå¹¶è®¾ç½® `errno` 
- å‚æ•°è¯´æ˜ï¼š
  - `fds` ï¼šä¼ å…¥ä¼ å‡ºå‚æ•°ï¼ˆstruct pollfdï¼‰:point_down: 
  - `nfds` ï¼šå†…æ ¸ç›‘æ§æ–‡ä»¶æè¿°èŒƒå›´ï¼Œç»“æ„ä½“æ•°ç»„æœ€å¤§ä¸‹æ ‡+1
  - `timeout` ï¼šè¶…æ—¶æ—¶é—´
    - `=-1`ï¼šè¡¨ç¤ºæ°¸ä¹…é˜»å¡ï¼Œç›´åˆ°æœ‰äº‹ä»¶å‘ç”Ÿ
    - `=0`ï¼šè¡¨ç¤ºä¸é˜»å¡ï¼Œä¸ç®¡æœ‰æ²¡æœ‰äº‹ä»¶å‘ç”Ÿ
    - `>0`ï¼šè¡¨ç¤ºé˜»å¡æ—¶é•¿  
                      è‹¥æ²¡æœ‰è¶…è¿‡æ—¶é•¿ï¼Œåˆ™ä¸€ç›´é˜»å¡  
                      è‹¥åœ¨æ—¶é•¿å†…æœ‰äº‹ä»¶å‘ç”Ÿï¼Œåˆ™ç«‹åˆ»è¿”å›  
                      è‹¥è¶…è¿‡æ—¶é•¿ï¼Œåˆ™ç«‹åˆ»è¿”å›

```C
struct pollfd {
    int   fd;         // file descriptor  (-1ï¼Œå†…æ ¸ä¸å†ç›‘å¬)
    short events;     // requested events (è¾“å…¥å‚æ•°ï¼šè¯»äº‹ä»¶ã€å†™äº‹ä»¶ã€å¼‚å¸¸äº‹ä»¶)
    short revents;    // returned events  (è¾“å‡ºå‚æ•°ï¼šå“ªäº›äº‹ä»¶å‘ç”Ÿ)
};
events & reventsï¼š
    POLLIN: å¯è¯»äº‹ä»¶
    POLLOUT: å¯å†™äº‹ä»¶
	POLLERR: å¼‚å¸¸äº‹ä»¶
```

ã€:card_index:ã€‘pollæœåŠ¡ç«¯å¼€å‘æµç¨‹

```C
1	åˆ›å»ºsocket
2	ç«¯å£å¤ç”¨setsockopt
3	ç»‘å®šbind  
4	ç›‘å¬listen 
5	struct pollfd client[1024];
	client[0].fd = lfd;
	client[0].events = POLLIN;
	int maxi = 0;
	for(i=1;i<1024;i++){
        client[i].fd = -1;
    }
6	while(1){
        nready = poll(client, maxi+1, -1);
        if(nready<0){											//pollå¼‚å¸¸
            if(errno==EINTR) continue;							//è¢«ä¿¡å·ä¸­æ–­
            break;
        }
        
        //å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚åˆ°è¾¾
        if(client[0].revents & POLLIN){
            //æ¥æ”¶æ–°çš„å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚
            cfd = accept(lfd, NULL, NULL);
            
            for(i=0;i<1024;i++){
                if(client[i].fd=-1){
                    client[i].fd = cfd;
                    client[i].events = POLLIN;
                    break;
                }
            }
            
            if(i==1024){
                close(cfd);
                continue;
            }
            if(maxi<i) maxi = i;								 //ä¿®æ”¹clientæ•°ç»„ä¸‹æ ‡æœ€å¤§å€¼
            if(--nready==0) continue;							//è¯¥å˜åŒ–å¤„ç†å®Œè‹¥å†æ— å…¶ä»–åˆ™è¿›è¡Œä¸‹ä¸€æ¬¡å¾ªç¯
        }
        
        //å®¢æˆ·ç«¯æ•°æ®åˆ°è¾¾
        for(i=1;i<=maxi;i++){
            if(client[i].fd==-1)
                continue;
            if(client[i].revents==POLLIN){
            	//readæ•°æ®
               	n = read(client[i].fd, buf, sizeof(buf));
                if(n<=0){										//readå¼‚å¸¸
                    close(client[i].fd);
                    client[i].fd = -1;
                }
                else{
                    //writeæ•°æ®
                	write(client[i].fd, buf, n); 
            	}
            	if(--nready==0) break;
            }
        }
    }
    close(lfd);
```

ã€:triangular_flag_on_post:ã€‘pollå‡½æ•°è¿”å›æ—¶ï¼Œ`fd` & `events` ä¸å‘ç”Ÿå˜åŒ–ï¼Œæ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿç”± `revents` åˆ¤æ–­   
			 struct pollfd ç»“æ„ä½“æˆå‘˜ `fd=-1` ï¼Œè¡¨ç¤ºå†…æ ¸æ²¡æœ‰ç›‘æ§  
			 pollå¯ä»¥çªç ´1024

## 2. å¤šè·¯IO-epoll

#### epoll_createå‡½æ•°

```C
#include <sys/epoll.h>
int epoll_create(int size);
```

- å‡½æ•°è¯´æ˜ï¼šåˆ›å»ºä¸€æ£µepollæ ‘ï¼Œè¿”å›ä¸€ä¸ªæ ¹èŠ‚ç‚¹
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šå¤§äº 0 çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä»£è¡¨epollæ ‘çš„æ ‘æ ¹
  - é”™è¯¯ï¼š-1ï¼Œå¹¶è®¾ç½® `errno` 
- å‚æ•°è¯´æ˜ï¼š
  - `size` ï¼šæœ€å¤§èŠ‚ç‚¹æ•°ï¼Œæ­¤å‚æ•°åœ¨linux2.6.8å·²è¢«å¿½ç•¥ï¼Œä½†å¿…é¡»ä¼ é€’ä¸€ä¸ªå¤§äº 0 çš„æ•°

#### epoll_ctlå‡½æ•°

```C
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

- å‡½æ•°è¯´æ˜ï¼šå°†fdæ·»åŠ /ä¿®æ”¹/åˆ é™¤è‡³epollæ ‘
- è¿”å›å€¼ï¼š
- å‚æ•°è¯´æ˜ï¼š
  - `epfd` ï¼šepollæ ‘çš„æ ¹èŠ‚ç‚¹
  - `op` ï¼š
    - EPOLL_CTL_ADD æ·»åŠ 
    - EPOLL_CTL_MOD ä¿®æ”¹
    - EPOLL_CTL_DEL åˆ é™¤
  - `fd` ï¼šæ–‡ä»¶æè¿°ç¬¦
  - `event` ï¼šä¼ å…¥å‚æ•°ï¼ˆstruct epoll_eventï¼‰:point_down: 

```C
typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
	uint64_t     u64;
} epoll_data_t;

struct epoll_event {
	uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
};
events:
	EPOLLINï¼šå¯è¯»äº‹ä»¶
    EPOLLOUTï¼šå¯å†™äº‹ä»¶
    EPOLLERRï¼šå¼‚å¸¸äº‹ä»¶
```

#### epoll_waitå‡½æ•°

```C
#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

- å‡½æ•°è¯´æ˜ï¼šå†…æ ¸ç›‘æ§epollæ ‘çš„äº‹ä»¶èŠ‚ç‚¹
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼š`>0` è¿”å›æœ‰äº‹ä»¶å‘ç”Ÿç»“æ„ä½“æ•°é‡  
    			`=0` è¶…æ—¶æ²¡æœ‰äº‹ä»¶å‘ç”Ÿ
  - é”™è¯¯ï¼š-1ï¼Œå¹¶è®¾ç½® `errno` 
- å‚æ•°è¯´æ˜ï¼š
  - `epfd` ï¼šepollæ ‘æ ¹èŠ‚ç‚¹
  - `events` ï¼šä¼ å‡ºå‚æ•°ï¼Œç»“æ„ä½“æ•°ç»„ï¼ˆstruct epoll_eventï¼‰:point_up_2: 
  - `maxevents` ï¼šæ•°ç»„å¤§å°
  - `timeout` ï¼šè¶…æ—¶æ—¶é—´
    - `=-1`ï¼šè¡¨ç¤ºæ°¸ä¹…é˜»å¡ï¼Œç›´åˆ°æœ‰äº‹ä»¶å‘ç”Ÿ
    - `=0`ï¼šè¡¨ç¤ºä¸é˜»å¡ï¼Œä¸ç®¡æœ‰æ²¡æœ‰äº‹ä»¶å‘ç”Ÿ
    - `>0`ï¼šè¡¨ç¤ºé˜»å¡æ—¶é•¿  
                è‹¥æ²¡æœ‰è¶…è¿‡æ—¶é•¿ï¼Œåˆ™ä¸€ç›´é˜»å¡  
                è‹¥åœ¨æ—¶é•¿å†…æœ‰äº‹ä»¶å‘ç”Ÿï¼Œåˆ™ç«‹åˆ»è¿”å›  
                è‹¥è¶…è¿‡æ—¶é•¿ï¼Œåˆ™ç«‹åˆ»è¿”å›

#### epollæ¨¡å‹

ã€:cactus:ã€‘epollæœåŠ¡ç«¯å¼€å‘æµç¨‹

```C
1	åˆ›å»ºsocket
2	ç«¯å£å¤ç”¨setsockopt
3	ç»‘å®šbind  
4	ç›‘å¬listen 
5	int epfd = epoll_create();									//åˆ›å»ºepollæ ‘
	struct epoll_event ev;
	ev.events = EPOLLIN;
	ev.data.fd = lfd;
	epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);					//lfdä¸Šæ ‘
6	struct epoll_event events[1024];
    while(1){
        nready = epoll_wait(epfd, events, 1024, -1);
        if(nready<0){											//epollå¼‚å¸¸
            if(errno==EINTR) continue;							//è¢«ä¿¡å·ä¸­æ–­
            break;
        }
        
        for(i=0;i<nready;i++){
            //å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚åˆ°è¾¾
        	if(events[i].data.fd==lfd){
            	//æ¥æ”¶æ–°çš„å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚
            	cfd = accept(lfd, NULL, NULL);
            	ev.events = EPOLLIN;
				ev.data.fd = cfd;
				epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);		//cfdä¸Šæ ‘
        	}
            //å®¢æˆ·ç«¯æ•°æ®åˆ°è¾¾
            else{												 
                //readæ•°æ®
               	n = read(events[i].data.fd, buf, sizeof(buf));
                if(n<=0){										//readå¼‚å¸¸
                    close(events[i].data.fd);
                    epoll_ctl(epfd, EPOLL_CTL_DEL, events[i].data.fd, NULL);
                }
                else{
                    //writeæ•°æ®
                	write(events[i].data.fd, buf, n); 
            	}
            }
        }
    }
    close(lfd);
	close(epfd);
```

ã€:pill:**TEST**ã€‘

```C
  1 //epollå¹¶å‘æœåŠ¡å™¨æµ‹è¯•
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 #include <errno.h>
 11 #include <sys/epoll.h>
 12 
 13 int main()
 14 {
 15     //åˆ›å»ºsocket
 16     int lfd = socket(AF_INET, SOCK_STREAM, 0);
 17     if(lfd<0)
 18     {
 19         perror("socket error");
 20         return -1;
 21     }
 22 
 23     //ç«¯å£å¤ç”¨
 24     int opt = 1;
 25     setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
 26 
 27     //ç»‘å®š
 28     struct sockaddr_in serv;
 29     bzero(&serv, sizeof(serv));
 30     serv.sin_family = AF_INET;
 31     serv.sin_port = htons(8888);
 32     serv.sin_addr.s_addr = htonl(INADDR_ANY);
 33     int ret = bind(lfd, (struct sockaddr*)&serv, sizeof(serv));
 34     if(ret<0)
 35     {
 36         perror("bind error");
 37         return -1;
 38     }
 39 
 40     //ç›‘å¬
 41     listen(lfd, 128);
 42 
 43     int epfd = epoll_create(1024);					//åˆ›å»ºepollæ ‘
 44     struct epoll_event ev;
 45     ev.events = EPOLLIN;
 46     ev.data.fd = lfd;								//lfdä¸Šæ ‘
 47     epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
 48 
 49     int i;
 50     int j;
 51     int n;
 52     int cfd;
 53     int nready;
 54     char buf[1024];
 55     struct epoll_event events[1024];
 56 
 57     while(1)
 58     {
 59         nready = epoll_wait(epfd, events, 1024, -1);
 60         if(nready<0)
 61         {
 62             if(errno==EINTR) continue;
 63         }
 64         break;
 65 
 66         //å¾ªç¯eventsæ•°ç»„
 67         for(i=0;i<nready;i++)
 68         {
 69             //å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚åˆ°è¾¾
 70             if(events[i].data.fd==lfd)
 71             {
 72                 cfd = accept(lfd, NULL, NULL);
 73                 ev.events = EPOLLIN;
 74                 ev.data.fd = cfd;
 75                 epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);
 76 
 77             }
 78             //å®¢æˆ·ç«¯æ•°æ®åˆ°è¾¾
 79             else
 80             {
 81                 //readæ•°æ®
 82                 memset(buf, 0x00, sizeof(buf));
 83                 n = read(events[i].data.fd, buf, size(buf));
 84                 if(n<=0)
 85                 {
 86                     close(events[i].data.fd);
 87                     epoll_ctl(epfd, EPOLL_CTL_DEL, events[i].data.fd, NULL);
 88                 }
 89                 else
 90                 {
 91                     printf("n==[%d],buf==[%s]\n", n, buf);
 92                     for(j=0;j<n;j++)
 93                     {
 94                         buf[j] = toupper(buf[j]);
 95                     }
 96                     //writeæ•°æ®
 97                     write(cfd, buf, n);
 98                 }
 99             }
100         }
101     }
102     close(lfd);
103     close(epfd);
104     return 0;
105 }

```

## 3. epollè¿›é˜¶

#### LTæ¨¡å¼å’ŒETæ¨¡å¼

æ°´å¹³è§¦å‘ï¼šé«˜ç”µå¹³ä»£è¡¨1  
				   åªè¦ç¼“å†²åŒºä¸­æœ‰æ•°æ®ï¼Œå°±ä¸€ç›´é€šçŸ¥

è¾¹ç¼˜è§¦å‘ï¼šç”µå¹³æœ‰å˜åŒ–å°±ä»£è¡¨1  
				   ç¼“å­˜åŒºä¸­æœ‰æ•°æ®åªä¼šé€šçŸ¥ä¸€æ¬¡ï¼Œä¹‹åå†æœ‰æ•°æ®æ‰ä¼šé€šçŸ¥

ã€:sweat_drops:ã€‘epoll LTæ¨¡å¼ï¼ˆé»˜è®¤æƒ…å†µï¼‰  
        	 åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œè‹¥è¯»æ•°æ®ä¸€æ¬¡æ€§æ²¡æœ‰è¯»å®Œï¼Œç¼“å†²åŒºè¿˜æœ‰å¯è¯»æ•°æ®ï¼Œåˆ™epoll_waitè¿˜ä¼šå†æ¬¡é€šçŸ¥

ã€:electric_plug:ã€‘epoll ETæ¨¡å¼  
		    `ev.events = EPOLLIN | EPOLLET`  
		    åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œè‹¥è¯»æ•°æ®ä¸€æ¬¡æ€§æ²¡æœ‰è¯»å®Œï¼Œç¼“å†²åŒºè¿˜æœ‰å¯è¯»æ•°æ®ï¼Œåˆ™epoll_waitä¸å†é€šçŸ¥ï¼Œç›´åˆ°ä¸‹æ¬¡æœ‰æ–°çš„æ•°æ®å‘æ¥

```C
epoll ETéé˜»å¡æ¨¡å¼ï¼š
å¾ªç¯è¯»ï¼Œç›´åˆ°æ•°æ®è¯»å–å®Œæˆï¼Œåˆ‡è®°è®¾ç½®é€šä¿¡æè¿°ç¬¦ä¸ºéé˜»å¡

int flag = fcntl(cfd, F_GETFL);
flag |= O_NONBLOCK;
fcntl(cfd, F_SETFL, flag);

while(1){
    n = read(events[i].data.fd, buf, size(buf));
    if(n==-1){										//æ•°æ®è¯»å–å®Œæˆ
        break;
    }
    else if(n==0){									//å®¢æˆ·ç«¯å…³é—­è¿æ¥
    	close(events[i].data.fd);
        epoll_ctl(epfd, EPOLL_CTL_DEL, events[i].data.fd, NULL);
        break;
    }
    else{
        printf("n==[%d],buf==[%s]\n", n, buf);
        for(j=0;j<n;j++){
        	buf[j] = toupper(buf[j]);
        }
        //writeæ•°æ®
        write(cfd, buf, n);
}
```

## 4. epollååº”å †



---
> âœï¸ [é‚¢ç¦å‡¯ (xfkcode@github)](https://github.com/xfkcode)  
> ğŸ“… **å†™äº2023å¹´2æœˆ** 