# ç½‘ç»œç¼–ç¨‹(5)ğŸ‘˜

## 1. çº¿ç¨‹æ± ğŸ¤¿



## 2. UDPé€šä¿¡ğŸ“¡

UDPï¼šç”¨æˆ·æ•°æ®æŠ¥åè®®  
é¢å‘æ— è¿æ¥çš„ï¼Œä¸ç¨³å®šçš„ï¼Œä¸å¯é çš„ï¼Œä¸å®‰å…¨çš„æ•°æ®æŠ¥ä¼ é€’ï¼ˆç±»ä¼¼æ”¶å‘çŸ­ä¿¡ï¼‰  
UDPä¼ è¾“ä¸éœ€è¦å»ºç«‹è¿æ¥ï¼Œä¼ è¾“æ•ˆç‡æ›´é«˜ï¼Œåœ¨ç¨³å®šçš„å±€åŸŸç½‘å†…ç¯å¢ƒç›¸å¯¹å¯é  

### recvfromå‡½æ•°

```C
#include <sys/types.h>
#include <sys/socket.h>
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```

- å‡½æ•°è¯´æ˜ï¼šæ¥æ”¶æ¶ˆæ¯
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šè¿”å›è¯»åˆ°çš„å­—èŠ‚æ•°
  - å¤±è´¥ï¼šè¿”å› -1 ï¼Œå¹¶è®¾ç½® `errno` 
- å‚æ•°è¯´æ˜ï¼š
  - `sockfd` ï¼šå¥—æ¥å­—
  - `buf` ï¼šè¦æ¥æ”¶çš„ç¼“å†²åŒº
  - `len` ï¼šç¼“å†²åŒºçš„é•¿åº¦
  - `flags` ï¼šæ ‡å¿—ä½ï¼Œä¸€èˆ¬å¡« 0
  - `src_addr` ï¼šåŸåœ°å€ä¼ å‡ºå‚æ•°
  - `addrlen` ï¼šå‘é€æ–¹åœ°å€é•¿åº¦

### sendtoå‡½æ•°

```C
#include <sys/types.h>
#include <sys/socket.h>
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
```

- å‡½æ•°è¯´æ˜ï¼šå‘é€æ•°æ®
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šè¿”å›å†™å…¥çš„å­—èŠ‚æ•°
  - å¤±è´¥ï¼šè¿”å› -1 ï¼Œå¹¶è®¾ç½® `errno` 
- å‚æ•°è¯´æ˜ï¼š
  - `sockfd` ï¼šå¥—æ¥å­—
  - `buf` ï¼šè¦å‘é€çš„ç¼“å†²åŒº
  - `len` ï¼šç¼“å†²åŒºçš„é•¿åº¦
  - `flags` ï¼šæ ‡å¿—ä½ï¼Œä¸€èˆ¬å¡« 0
  - `dest_addr` ï¼šç›®çš„åœ°å€
  - `addrlen` ï¼šç›®çš„çš„åœ°å€é•¿åº¦

### UDPï¼šserver/clientå¼€å‘æµç¨‹

ã€**æœåŠ¡ç«¯server**:computer:ã€‘

```C
1	åˆ›å»ºsocket,type = SOCK_DGRAM
2	ç»‘å®šbind
3   while(1){
    	æ”¶æ¶ˆæ¯recvfrom
        å‘æ¶ˆæ¯sendto
	}
4	å…³é—­close
```

ã€:pill:**TEST**ã€‘

```C
  1 //UDPæœåŠ¡å™¨æµ‹è¯•
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 
 11 int main()
 12 {
 13     //åˆ›å»ºsocket
 14     int cfd = socket(AF_INET, SOCK_DGRAM, 0);
 15     if(cfd<0){
 16         perror("socket error");
 17         return -1;
 18     }
 19     //ç»‘å®š
 20     struct sockaddr_in serv;
 21     struct sockaddr_in client;
 22     bzero(&serv, sizeof(serv));
 23     serv.sin_family = AF_INET;
 24     serv.sin_port = htons(8888);
 25     serv.sin_addr.s_addr = htonl(INADDR_ANY);
 26     int ret = bind(cfd, (struct sockaddr*)&serv, sizeof(serv));
 27     if(ret<0){
 28         perror("bind error");
 29         return -1;
 30     }
 31 
 32     int i = 0;
 33     int n = 0;
 34     socklen_t len;
 35     char buf[1024];
 36     while(1){
 37         //æ¥æ”¶æ•°æ®
 38         memset(buf, 0x00, sizeof(buf));
 39         len = sizeof(client);
 40         n = recvfrom(cfd, buf, sizeof(buf), 0, (struct sockaddr *)&client, &len);
 41         printf("[%d]:n==[%d],buf==[%s]\n", ntohs(client.sin_port), n, buf);
 42         //å‘é€æ•°æ®
 43         for(i=0;i<n;i++){
 44             buf[i] = toupper(buf[i]);
 45         }
 46         sendto(cfd, buf, n, 0, (struct sockaddr *)&client, len);
 47     }
 48     //å…³é—­  
 49     close(cfd);
 50     return 0;
 51 }

 >>>>æ‰§è¡Œç»“æœ
 [xfk@centos SOCKET]$ ./server_UDP
 [51115]:n==[4],buf==[xfk
 ]
 [37561]:n==[3],buf==[tq
 ]
 [xfk@centos ~]$ nc -u 127.1 8888
 xfk
 XFK
 [xfk@centos ~]$ nc -u 127.1 8888
 tq
 TQ
```

ã€:ticket:ã€‘`nc -u 127.1 8888` ï¼š`-u` å‚æ•°ï¼Œå¯æµ‹è¯•UDP

ã€:construction:ã€‘æŸ¥çœ‹ç½‘ç»œçŠ¶æ€

```Linux
[xfk@centos ~]$ netstat -anp | grep 8888
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
udp        0      0 0.0.0.0:8888            0.0.0.0:*                           30392/./server_UDP  
udp        0      0 127.0.0.1:37561         127.0.0.1:8888          ESTABLISHED 30393/nc            
udp        0      0 127.0.0.1:51115         127.0.0.1:8888          ESTABLISHED 30448/nc
```

ã€**å®¢æˆ·ç«¯client**:iphone:ã€‘

```C
1	åˆ›å»ºsocket
2   while(1){
        å‘æ¶ˆæ¯sendto
        æ”¶æ¶ˆæ¯recvfrom
	}
3	å…³é—­close
```

ã€:pill:**TEST**ã€‘

```C
  1 //UDPå®¢æˆ·ç«¯æµ‹è¯•
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 
 11 int main()
 12 {
 13     //åˆ›å»ºsocket
 14     int cfd = socket(AF_INET, SOCK_DGRAM, 0);
 15     if(cfd<0){
 16         perror("socket error");
 17         return -1;
 18     }
 19 
 20     int i = 0;
 21     int n = 0;
 22     char buf[1024];
 23     struct sockaddr_in serv;
 24 
 25     serv.sin_family = AF_INET;
 26     serv.sin_port = htons(8888);
 27     inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
 28 
 29     while(1){
 30         //å‘é€æ•°æ®
 31         memset(buf, 0x00, sizeof(buf));
 32         n = read(STDIN_FILENO, buf, sizeof(buf));
 33         sendto(cfd, buf, n, 0, (struct sockaddr *)&serv, sizeof(serv));
 34         //æ¥æ”¶æ•°æ®
 35         memset(buf, 0x00, sizeof(buf));
 36         n = recvfrom(cfd, buf, sizeof(buf), 0, NULL, NULL);
 37         printf("[server]:n==[%d],buf==[%s]\n", n, buf);
 38     }
 39     //å…³é—­  
 40     close(cfd);
 41     return 0;
 42 }

 >>>>æ‰§è¡Œç»“æœ
 [xfk@centos SOCKET]$ ./server_UDP
 [50712]:n==[4],buf==[xfk
 ]
 [38975]:n==[3],buf==[tq
 ]
 [xfk@centos SOCKET]$ ./client_UDP 
 xfk
 [server]:n==[4],buf==[XFK
 ]
 [xfk@centos SOCKET]$ ./client_UDP 
 tq
 [server]:n==[3],buf==[TQ
 ]
```

ã€:construction:ã€‘æŸ¥çœ‹ç½‘ç»œçŠ¶æ€

```Linux
[xfk@centos ~]$ netstat -anp | grep server
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (servers and established)
udp        0      0 0.0.0.0:8888            0.0.0.0:*                           31315/./server_UDP  
Active UNIX domain sockets (servers and established)
[xfk@centos ~]$ netstat -anp | grep client
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
udp        0      0 0.0.0.0:50712           0.0.0.0:*                           31343/./client_UDP  
udp        0      0 0.0.0.0:38975           0.0.0.0:*                           31330/./client_UDP
```

## 3. æœ¬åœ°socketé€šä¿¡ğŸ›µ

### socketå‡½æ•°

```C
#include <sys/socket.h>
#include <sys/un.h>
int socket(int domain, int type, int protocol);
```

- å‡½æ•°è¯´æ˜ï¼šåˆ›å»ºæœ¬åœ°socket
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šè¿”å›æ–‡ä»¶æè¿°ç¬¦
  - å¤±è´¥ï¼šè¿”å› -1 ï¼Œå¹¶è®¾ç½® `errno` 
- å‚æ•°è¯´æ˜ï¼š
  - `domain` ï¼šAF_UNIX  or  AF_LOCAL
  - `type` ï¼šSOCK_STREAMï¼ˆTCPï¼‰  
                   SOCK_DGRAMï¼ˆUDPï¼‰
  - `protocol` ï¼šé»˜è®¤åè®®

### bindå‡½æ•°

```C
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- å‡½æ•°è¯´æ˜ï¼šç»‘å®šå¥—æ¥å­—
- è¿”å›å€¼ï¼š
  - æˆåŠŸï¼šè¿”å›æ–‡ä»¶æè¿°ç¬¦
  - å¤±è´¥ï¼šè¿”å› -1 ï¼Œå¹¶è®¾ç½® `errno` 
- å‚æ•°è¯´æ˜ï¼š
  - `sockfd` ï¼šsocketè¿”å›çš„æ–‡ä»¶æè¿°ç¬¦
  - `addr` ï¼šæœ¬åœ°åœ°å€
  - `addrlen` ï¼šæœ¬åœ°åœ°å€é•¿åº¦

```C
#define UNIX_PATH_MAX    108
struct sockaddr_un {
	sa_family_t sun_family;               /* AF_UNIX */
    char        sun_path[UNIX_PATH_MAX];  /* pathname */
};
```

### æœ¬åœ°socketé€šä¿¡ï¼šserver/clientå¼€å‘æµç¨‹(TCP)

ã€**æœåŠ¡ç«¯server**:computer:ã€‘  
  æœ¬åœ°socketé€šä¿¡æœåŠ¡å™¨å¼€å‘æµç¨‹

```C
1	åˆ›å»ºsocket
    lfd = socket(AF_UNIX, SOCK_STREAM, 0);
2	ç»‘å®šbind
    struct sockaddr_un serv;
	bzero(&serv, sizeof(serv));
	serv,sun_family = AF_UNIX;
	strcpy(serv.sun_path, "./serv.sock");
	bind(lfd, (struct sockaddr *)&serv, sizeof(serv));
3	ç›‘å¬listen
4   æ¥æ”¶æ–°çš„å®¢æˆ·ç«¯accept
5	while(1){
    	è¯»æ•°æ®read
    	å†™æ•°æ®write
	}
	close(cfd);
	close(lfd);
```

ã€:pill:**TEST**ã€‘

```C
  1 //æœ¬åœ°socketé€šä¿¡æœåŠ¡å™¨æµ‹è¯•
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <sys/un.h>
  9 #include <arpa/inet.h>
 10 #include <ctype.h>
 11 
 12 int main()
 13 {
 14     //åˆ›å»ºsocket
 15     int lfd = socket(AF_UNIX, SOCK_STREAM, 0);
 16     if(lfd<0){
 17         perror("socket error\n");
 18         return -1;
 19     }
 20 
 21     //åˆ é™¤serv.sockæ–‡ä»¶
 22     unlink("./serv.sock");
 23 
 24     //ç»‘å®š
 25     struct sockaddr_un serv;
 26     bzero(&serv, sizeof(serv));
 27     serv.sun_family = AF_UNIX;
 28     strcpy(serv.sun_path, "./serv.sock");
 29     int ret = bind(lfd, (struct sockaddr*)&serv, sizeof(serv));
 30     if(ret<0){
 31         perror("bind error\n");
 32         return -1;
 33     }
 34 
 35     //ç›‘å¬
 36     listen(lfd, 128);
 37 
 38     //æ¥æ”¶æ–°å®¢æˆ·ç«¯
 39     struct sockaddr_un client;
 40     socklen_t len = sizeof(client);
 41     int cfd = accept(lfd, (struct sockaddr *)&client, &len);
 42     if(cfd<0){
 43         perror("accept error\n");
 44         return -1;
 45     }
 46 
 47     int i = 0;
 48     int n = 0;
 49     char buf[1024];
 50     while(1){
 51         //è¯»æ•°æ®
 52         memset(buf, 0x00, sizeof(buf));
 53         n = read(cfd, buf, sizeof(buf));
 54         if(n<=0){
 55             printf("read error or client close\n");
 56             break;
 57         }
 58         printf("n==[%d],buf==[%s]\n", n, buf);
 59         //å†™æ•°æ®
 60         for(i=0;i<n;i++){
 61             buf[i] = toupper(buf[i]);
 62         }
 63         write(cfd, buf, n);
 64     }
 65     //å…³é—­
 66     close(lfd);
 67     close(cfd);
 68     return 0;
 69 }

 >>>>æ‰§è¡Œç»“æœ
 [xfk@centos SOCKET]$ ./server_local 
 n==[4],buf==[xfk
 ]
 read error or client close
 [xfk@centos SOCKET]$ nc -U ./serv.sock 
 xfk
 XFK
 ^C
```

ã€:ticket:ã€‘`nc -U ./serv.sock` ï¼š`-U` å‚æ•°ï¼Œå¯æµ‹è¯•æœ¬åœ°socketé€šä¿¡

ã€**å®¢æˆ·ç«¯client**:iphone:ã€‘  
  æœ¬åœ°socketé€šä¿¡å®¢æˆ·ç«¯å¼€å‘æµç¨‹

```C
1	åˆ›å»ºsocket
    lfd = socket(AF_UNIX, SOCK_STREAM, 0);
2   è¿æ¥æœåŠ¡å™¨connect
3	while(1){
    	å†™æ•°æ®write
    	è¯»æ•°æ®read 
	}
	close(cfd);
```

ã€:pill:**TEST**ã€‘

```C
  1 //æœ¬åœ°socketé€šä¿¡å®¢æˆ·ç«¯æµ‹è¯•
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <sys/un.h>
  9 #include <arpa/inet.h>
 10 #include <ctype.h>
 11 
 12 int main()
 13 {
 14     //åˆ›å»ºsocket
 15     int cfd = socket(AF_UNIX, SOCK_STREAM, 0);
 16     if(cfd<0){
 17         perror("socket error\n");
 18         return -1;
 19     }
 20 
 21     //è¿æ¥æœåŠ¡å™¨
 22     struct sockaddr_un serv;
 23     bzero(&serv, sizeof(serv));
 24     serv.sun_family = AF_UNIX;
 25     strcpy(serv.sun_path, "./serv.sock");
 26     connect(cfd, (struct sockaddr*)&serv, sizeof(serv));
 27 
 28     int n = 0;
 29     char buf[1024];
 30     while(1){
 31         //å†™æ•°æ®
 32         memset(buf, 0x00, sizeof(buf));
 33         n = read(STDIN_FILENO, buf, sizeof(buf));
 34         write(cfd, buf, n);
 35         //è¯»æ•°æ®
 36         memset(buf, 0x00, sizeof(buf));
 37         n = read(cfd, buf, sizeof(buf));
 38         if(n<=0){
 39             printf("read error or server close\n");
 40             break;
 41         }
 42         printf("n==[%d],buf==[%s]\n", n, buf);
 43     }
 44     //å…³é—­
 45     close(cfd);
 46     return 0;
 47 }

 >>>>æ‰§è¡Œç»“æœ
 [xfk@centos SOCKET]$ ./server_local 
 n==[4],buf==[xfk
 ]
 read error or client close
 [xfk@centos SOCKET]$ ./client_local 
 xfk
 n==[4],buf==[XFK
 ]
 ^C
```

ã€:bowling:ã€‘**client** ç»‘å®š

```C
unlink("./client.sock");
struct sockaddr_un client;
bzero(&client, sizeof(client));
client.sun_family = AF_UNIX;
strcpy(client.sun_path, "./client.sock");
int ret = bind(lfd, (struct sockaddr*)&client, sizeof(client));
if(ret<0){
     perror("bind error\n");
     return -1;
}
```

---
> âœï¸ [é‚¢ç¦å‡¯ (xfkcode@github)](https://github.com/xfkcode)  
> ğŸ“… **å†™äº2023å¹´2æœˆ** 